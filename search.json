[{"title":"搜索集合","url":"https://zzhy0616.github.io/2020/11/07/搜索集合-1/","content":"特殊状态的枚举关于函数next_pumutation，可以把n个元素共n！种排列枚举出来\nbool  used[MAX_N];\nint perm[MAX_N];\n\n&#x2F;&#x2F;生成&#123;0， 1， 2 ，3， 4 ，... n- 1&#125; 的 n！序列\nvoid permutation(int pos , int n)&#123;\n    if(pos &#x3D;&#x3D; n) &#123;\n        &#x2F;*\n        对perm进行的操作\n        *&#x2F;\n    return ;\n    &#125;\n    for(int i &#x3D; 0; i&lt; n; ++i) &#123;\n        if(!used[i])&#123;\n            perm[pos] &#x3D; i;\n            used[i] &#x3D; true;\n            permutation(pos + 1, n);\n            used[i] &#x3D; false;\n        &#125;\n    &#125;\n    return ;\n&#125;\n#include &lt;algorithm&gt;\n\nint perm2[MAX_N];\n&#x2F;&#x2F; 按字典序生成下一个序列\nvoid permutation (int n)&#123; \n    for(int i &#x3D; 0; i &lt; n; ++i) &#123;\n        perm2 [i]   &#x3D;  i;\n\n    &#125;\n    do &#123;\n\n    &#125;\n    while(next_permutation(perm2, perm2 + n));\n    return ;\n&#125;\n\nDescriptions:给定若干位十进制数，你可以通过选择一个非空子集并以某种顺序构建一个数。剩余元素可以用相同规则构建第二个数。除非构造的数恰好为0，否则不能以0打头。 \n举例来说，给定数字0，1，2，4，6与7，你可以写出10和2467。当然写法多样：210和764，204和176，等等。最后一对数差的绝对值为28，实际上没有其他对拥有更小的差。\nInput输入第一行的数表示随后测试用例的数量。对于每组测试用例，有一行至少两个不超过10的十进制数字。（十进制数字为0，1，…，9）每行输入中均无重复的数字。数字为升序给出，相隔恰好一个空格。\nOutput对于每组测试用例，输出一个以上述规则可获得的最小的差的绝对值在一行。\nSample Input10 1 2 4 6 7\nSample Output28\n解题思路所需数字需要绝对值最小，即两个数字的数位相似，故枚举即可。\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;fstream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;deque&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#include &lt;map&gt;\n#include &lt;stack&gt;\n#include &lt;set&gt;\n#include &lt;sstream&gt;\nusing namespace std;\n\nint num[1005];\nint q;\nint ans;\nconst int INF &#x3D; 100010 + 7;\nvoid solve()&#123;\n    while(q--)&#123;\n        int len &#x3D; 0;\n        char ch;\n        while(1)&#123;\n            scanf(&quot;%d%c&quot;, &amp;num[len++], &amp;ch);\n            if(ch &#x3D;&#x3D; &#39;\\n&#39;)\n                break;\n        &#125;\n        if(len &#x3D;&#x3D; 2)&#123;\n            printf(&quot;%d\\n&quot;, abs(num[0]- num[1]));\n            continue;\n        &#125;\n        int n1, n2;\n        ans &#x3D; INF;\n        int mid &#x3D; len &#x2F;2;\n        do&#123;\n            n1 &#x3D; num[0], n2 &#x3D; num[mid];\n            if(n1 &#x3D;&#x3D; 0 || n2 &#x3D;&#x3D; 0)\n                continue;\n            for(int i &#x3D; 1; i &lt; mid; ++i)\n             n1 &#x3D; n1 * 10 + num[i];\n            for(int i &#x3D; mid + 1; i &lt; len; ++i)\n                n2 &#x3D; n2 *10 + num[i];\n            ans &#x3D; min(ans, abs(n1 - n2));\n        &#125;    \n            while(next_permutation(num, num + len));\n        cout &lt;&lt; ans &lt;&lt; endl;\n    &#125;\n&#125;\nint main()&#123;\n    scanf(&quot;%d&quot;, &amp;q);\n    solve();\n&#125;","categories":[],"tags":[]},{"title":"","url":"https://zzhy0616.github.io/2020/11/07/搜索集合/","content":"","categories":[],"tags":[]},{"title":"MST","url":"https://zzhy0616.github.io/2020/09/20/MST/","content":"","categories":[],"tags":[]},{"title":"unionfind","url":"https://zzhy0616.github.io/2020/09/20/unionfind/","content":"经典并查集题目find（）和union操作\n\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\nconst int  N &#x3D; 300005;\n\nint Father[N], Rank[N];&#x2F;&#x2F;Father节点数据， Rank树的大小\n&#x2F;&#x2F; 递归find操作\nint find(int x)&#123;\n    if(Father[x] &#x3D;&#x3D; x)&#123;\n        return x;\n    &#125; else &#123;\n        return Father[x] &#x3D; find(Father[x]);\n    &#125;\n&#125;\nstring getAnswer(int n, int m, vector&lt;int&gt; A, vector&lt;int&gt; B, vector&lt;int&gt; E) &#123;\n    &#x2F;&#x2F;初始化\n    for(int i &#x3D; 0; i &lt;&#x3D; n; ++i)&#123;\n        Father[i] &#x3D; i;\n        Rank[i] &#x3D; 0;\n    &#125;\n    &#x2F;&#x2F;排序使1操作位于前\n    int cnt &#x3D; 0;\n    for(int i &#x3D; 0; i &lt; m ; ++i)&#123;\n        if(E[i] &#x3D;&#x3D; 1)&#123;\n            swap(E[i], E[cnt]);\n            swap(A[i], A[cnt]);\n            swap(B[i], B[cnt]);\n            cnt++;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;union操作\n    for(int i &#x3D; 0; i &lt; m; ++i)&#123;\n        int setA &#x3D; find(A[i]);\n        int setB &#x3D; find(B[i]);\n        if(E[i] &#x3D;&#x3D; 0)&#123;\n            if(setA &#x3D;&#x3D; setB)\n            return &quot;No&quot;;\n\n        &#125;else &#123;\n            if(setA !&#x3D; setB)&#123;\n                &#x2F;&#x2F;使小树加入大树\n                if(Rank[setB] &lt; Rank[setA])\n                    swap(setA, setB);\n                Father[setA] &#x3D; setB;\n                if(Rank[setA] &#x3D;&#x3D; Rank[setB])\n                    Rank[setA]++;              \n         &#125;\n        &#125;\n    &#125;\n    return &quot;Yes&quot;;\n&#125;\n\n\n\nint main() &#123;\n    int T;\n    for (scanf(&quot;%d&quot;, &amp;T); T--; ) &#123;\n        int n, m;\n        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n        vector&lt;int&gt; A, B, E;\n        for (int i &#x3D; 0; i &lt; m; ++i) &#123;\n            int a, b, e;\n            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;e);\n            A.push_back(a);\n            B.push_back(b);\n            E.push_back(e);\n        &#125;\n        printf(&quot;%s\\n&quot;, getAnswer(n, m, A, B, E).c_str());\n    &#125;\n    return 0;\n\n&#125;","categories":[],"tags":[]},{"title":"Hash","url":"https://zzhy0616.github.io/2020/09/20/Hash/","content":"哈希题目\ninclude &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\n\ntypedef long long ll;\n\nconst int Mod &#x3D; 1000003;\nvector&lt;ll&gt; table[Mod];\n\nint Hash(ll x)&#123;\n    return x  % Mod; \n&#125;\n&#x2F;&#x2F;hash操作\nbool check(int op, ll x) &#123;\n    int h &#x3D; Hash(x);\n    &#x2F;&#x2F;初始化\n    vector&lt;ll&gt;:: iterator ptr &#x3D; table[h].end();\n    for(vector&lt;ll&gt;::iterator it &#x3D; table[h].begin(); it !&#x3D; table[h].end(); ++it)\n      if(*it &#x3D;&#x3D; x)&#123;\n          ptr &#x3D; it;\n          break;\n      &#125;&#x2F;&#x2F;找到元素的位置\n    if(op &#x3D;&#x3D; 1)&#123;\n        if(ptr &#x3D;&#x3D; table[h].end())&#123;\n            table[h].push_back(x);\n            &#x2F;&#x2F;濡傛灉婊¤冻鍒檟涓嶅瓨鍦?\n            return 1;\n\n        &#125;\n        return 0;\n    &#125; else &#123;\n        if(ptr !&#x3D; table[h].end())&#123;\n            *ptr &#x3D; table[h].back();\n            table[h].pop_back();\n            return 1;\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 盲禄拢莽聽聛氓庐啪莽沤掳莽禄鈥溍β澟?&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\nint main() &#123;\n    int Q, op;\n    ll x;\n    scanf(&quot;%d&quot;, &amp;Q);\n    while (Q--) &#123;\n        scanf(&quot;%d%lld&quot;, &amp;op, &amp;x);\n        puts(check(op, x) ? &quot;Succeeded&quot; : &quot;Failed&quot;);\n    &#125;\n    return 0;\n&#125;\n","categories":[],"tags":[]},{"title":"Huffuman","url":"https://zzhy0616.github.io/2020/09/20/Huffuman/","content":"","categories":[],"tags":[]},{"title":"二叉树","url":"https://zzhy0616.github.io/2020/09/20/二叉树/","content":"#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 100005;\n\nstruct node &#123;\n\tint val, l, r;\n&#125; t[N];\n\nint root, cnt;\n&#x2F;&#x2F;ÔÚÒÔxÎª¸ùµÄÊ÷ÖÐ²åÈëÒ»¸öÊý×Öv\n&#x2F;&#x2F;v:Òª²åÈëµÄÊý×Ö\n&#x2F;&#x2F;x£ºµ±Ç°½Úµã\n&#x2F;&#x2F;·µ»ØÖµ£ºx \nint insert(int v, int x)&#123;\n\tif(x &#x3D;&#x3D; 0)&#123;\n\t\tx &#x3D; ++cnt;\n\t\tt[x].val &#x3D; v;\n\t\tt[x].r &#x3D; 0;\n\t\tt[x].l &#x3D; 0;\n\t\treturn x;\n\t&#125;\n\tif(t[x].val &gt; v)\n\tt[x].l &#x3D; insert(v, t[x].l);\n\telse \n\tt[x].r            veturn x;\n&#125;\n\nvoid dlr(int x, vector&lt;int&gt; &amp;ans)&#123;\n\tif(x)&#123;\n\t\tans.push_back(t[x].val);\n\t\tdlr(t[x].l,ans);\n\t\tdlr(t[x].r,ans);\n\t&#125;\n&#125;\n\nint lrd(int x, vector&lt;int&gt; &amp;ans)&#123;\n\tif(x)&#123;\n\t\tlrd(t[x].l,ans);\n\t\tlrd(t[x].r,ans);\n\t\tans.push_back(t[x].val);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;¿É¼Ç×ö¸ù×óÓÒ¡£Ç°Ðò±éÀúÊ×ÏÈ·ÃÎÊ¸ù½áµãÈ»ºó±éÀú×ó×ÓÊ÷£¬×îºó±éÀúÓÒ×ÓÊ÷¡£ \nvector&lt;int&gt; getAnswer(int n, vector&lt;int&gt; sequence) &#123;\n\troot &#x3D; cnt &#x3D; 0;\n\tfor(int i &#x3D; 0; i &lt; int(sequence.size()); ++i)&#123;\n\t\troot &#x3D; insert(sequence[i], root);\n\t&#125;\n\tvector&lt;int&gt; ans;\n\tdlr(root, ans);\n\tlrd(root, ans);\n\t\n\treturn ans;\n&#125;\n\n\n\nint main() &#123;\n    int n;\n    scanf(&quot;%d&quot;, &amp;n);\n    vector&lt;int&gt; sequence;\n    for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n        int x;\n        scanf(&quot;%d&quot;, &amp;x);\n        sequence.push_back(x);\n    &#125;\n    vector&lt;int&gt; ans &#x3D; getAnswer(n, sequence);\n    for (int i &#x3D; 0; i &lt; n; ++i)\n        printf(&quot;%d%c&quot;, ans[i], &quot; \\n&quot;[i &#x3D;&#x3D; n - 1]);\n    for (int i &#x3D; 0; i &lt; n; ++i)\n        printf(&quot;%d%c&quot;, ans[n + i], &quot; \\n&quot;[i &#x3D;&#x3D; n - 1]);\n    return 0;\n&#125;","categories":[],"tags":[]},{"title":"TO DO LIST","url":"https://zzhy0616.github.io/2020/08/21/TO-DO-LIST/","content":"","categories":[],"tags":[]},{"title":"April week 1题单","url":"https://zzhy0616.github.io/2020/03/27/April-week-1提单/","content":"\nP2249 【深基13.例1】查找\nP1102 A-B 数对\nP1873 砍树\nP1024 一元三次方程求解\nP1678 烦恼的高考志愿\nP2440 木材加工\nP3853 [TJOI2007]路标设置\nP1163 银行贷款\nP3743 kotori的设备\n象棋\n序列计数\n最小交换\n楼尔邦德完成情况(1/13)\n\n","categories":[],"tags":[]},{"title":"位运算","url":"https://zzhy0616.github.io/2020/02/05/位运算/","content":"\n\n\n符号\n描述\n运算规则\n\n\n\n&amp;\n与\n两个位都为1时，结果才为1\n\n\n|\n或\n两个位都为0时，结果才为0\n\n\n^\n异或\n两个位相同为0，相异为1\n\n\n~\n非\n0变1，1变0\n\n\n&lt;&lt;\n左移\n各二进位全部左移若干位，高位丢弃，低位补0\n\n\n&gt;&gt;\n右移\n各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移\n\n\n","categories":[],"tags":[]},{"title":"二分答案 分组","url":"https://zzhy0616.github.io/2020/02/03/二分答案分组/","content":"描述有n个正整数排成一排，你要将这些数分成m份（同一份中的数字都是连续的，不能隔开），同时数字之和最大的那一份的数字之和尽量小。\n输入输入的第一行包含两个正整数n，m。\n接下来一行包含n个正整数。\n输出输出一个数，表示最优方案中，数字之和最大的那一份的数字之和。\ninclude &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\n\n&#x2F;&#x2F;判断数组a是否能分成不超过m份， 满足每份都不超过d\n&#x2F;&#x2F; n:数组a的大小\n&#x2F;&#x2F;返回值：若能分成不超过m份， 返回true， 否则返回false\nbool check(long long d, int n, int m, vector&lt;int&gt; &amp;a)&#123;\n    long long sum &#x3D; 0; &#x2F;&#x2F;记录当前一份数字的和\n    int cnt &#x3D; 1;&#x2F;&#x2F;在每一份数字之和不超过d的情况下，至少要分成的份数\n\n    for( int i &#x3D; 0; i &lt; n; i++)&#123;\n        if(a[i] &gt; d) &#x2F;&#x2F; 如果单个元素超过d， 直接结束返回false\n           return false;\n        \n        sum +&#x3D; a[i];&#x2F;&#x2F; 将a[i]加入当前这一份中\n        if(sum &gt; d)&#123;\n            sum &#x3D; a[i];\n            ++cnt;\n        &#125; &#x2F;&#x2F;加入a[i]后，若超过d，至少分成的数加一\n    &#125;\n    return cnt &lt;&#x3D; m; \n&#125;\n\n\nlong long getAnswer(int n, int m, vector&lt;int&gt; a) &#123;\n    &#x2F;&#x2F; l表示答案的下界，r表示答案的上界\n    long long l &#x3D; 1, r &#x3D; 0;\n   &#x2F;&#x2F;求出答案的上界\n    for(int i &#x3D; 0; i &lt; n; i++)&#123;\n        r +&#x3D; a[i];\n    &#125;\n   &#x2F;&#x2F; 二分答案\n    while(l &lt;&#x3D; r)&#123;\n        long long mid &#x3D; (l + r) &gt;&gt; 1;\n        if(check(mid, n , m, a))\n            r &#x3D; mid - 1;\n        else \n            l &#x3D; mid + 1;\n    &#125;\n\n    return  r + 1; \n&#125;\n\n\nint main() &#123;\n    int n, m;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n    vector&lt;int&gt; a;\n    a.resize(n);\n    for (int i &#x3D; 0; i &lt; n; ++i)\n        scanf(&quot;%d&quot;, &amp;a[i]);\n    printf(&quot;%lld\\n&quot;, getAnswer(n, m, a));\n    return 0;\n&#125;","categories":[],"tags":[]},{"title":"链表","url":"https://zzhy0616.github.io/2020/01/17/链表/","content":"链表可以使用结构体来存储 struct slist {int prev, value, next;}list[enough];也可以直接使用若干个数组来实现int prev[enough], value[enough], next[enough]; \nint del(int x) &#123; \n// 删除链表中的 x \nnext[prev[x]] = next[x]; \nprev[next[x]] = prev[x]; \n&#125;\nint ins(int x, int y) &#123; \n// 在 x 的右边 (next) 插入y \nprev[next[x]] = y; \nnext[y] = next[x]; \nnext[x] = y; \nprev[y] = x;\n&#125;\n","categories":[],"tags":[]},{"title":"STL","url":"https://zzhy0616.github.io/2020/01/17/STL/","content":"pair 结构体▶ 可以将两种类型融合成一种类型▶ 就比如一个区间可以用两个端点表示，例如区间 [1,3] pair&lt;int, int&gt; range; range.first = 1, range.second = 3;▶ 可以是不同的类型，就比如一个人有学号 12，得分 99.2 pair&lt;int, double&gt; p; p.first = 12, p.second = 99.2;▶ 不难发现，使用 pair 应该将两种类型放到尖括号内，前一种类 型为 first，后一种为 second▶ 可以用括号赋值，只能在定义的时用pair&lt;int, char&gt; q(3, ‘a’); // 正确q(4, ‘b’); // 错误，只能定义时用\nmake_pair函数可以将两个数融合成一个pairpair&lt;int, int&gt; s = make_pair(2, 3); \n比较先比较first 再比较second\nsort函数▶ a[15] = {9, 2, 3, 1, 4, 3, 6, 5, 2, 10};▶ 从小到大排序 sort(a, a + 10);▶ 从大到小排序 sort(a, a + 10, greater());▶ 使用 greater 可能需要 #include ▶ sort 函数前两个参数是地址，记为 l,r，排序的区间为 [l,r)▶ 有 n 个区间 (l[i], r[i])，将这 n 个区间以左端点为第一关键 字，右端点按第二关键字从小到大排序pair&lt;int, int&gt; range[enough]; for(int i = 1; i &lt;= n; ++i) range[i] = make_pair(l[i], r[i]); sort(range + 1, range + n + 1);▶ 有 n 个区间 (l[i], r[i])，将这 n 个区间以左端点为第一关键 字，右端点按第二关键字且左端点递增，右端点递减排序pair&lt;int, int&gt; range[enough]; for(int i = 1; i &lt;= n; ++i) range[i] = make_pair(l[i], -r[i]); sort(range + 1, range + n + 1);\nunique 去重函数先排序，然后把相邻的相同元素删掉sort(a + 1, a + n + 1);n = unique(a + 1, a + n + 1) - a - 1; \nlower_bound, upper_bound 函数lower_bound(l, r, v) 可以得到在 [l,r) 内第一个大于等于 v 的 位置upper_bound(l, r, v) 可以得到在 [l,r) 内第一个大于 v 的位置 \npriority_queuepriority_queue 可以快速的支持插入，查找最大值，删除最大值 的操作\n定义一个 priority_queuepriority_queue que; \n插入一个 xque.push(x); \n查找最大值maxvalue = que.top();\n删除最大值que.pop();\n定义最小priority_queue&lt;int, vector, greater &gt; q \n","categories":[],"tags":[]},{"title":"Binary","url":"https://zzhy0616.github.io/2020/01/14/Binary/","content":"二分搜索（Binary Search）template &lt;typename T&gt; static Rank binSearch (T* s,T const &amp; e, Rank lo, Rank hi)&#123;\n    while( lo &lt; hi)&#123;&#x2F;&#x2F;不变性：A[0,lo) &lt;&#x3D; e &lt;&#x3D; A[ hi,n)\n        Rank mi &#x3D; (lo + hi) &gt;&gt; 1;&#x2F;&#x2F;以中点为轴点，经比较后确定深入\n        e &lt; S[mi] ? hi &#x3D; mi : lo &#x3D; mi + 1; &#x2F;&#x2F;[lo,mi) 或[mi,hi)\n    &#125; &#x2F;&#x2F;出口时，A[lo &#x3D; hi]为大于e的最小元素\n    return --lo;&#x2F;&#x2F;故lo - 1即不大于e的元素的最大秩\n&#125;","categories":[],"tags":["二分"]},{"title":"学习笔记","url":"https://zzhy0616.github.io/2020/01/14/2020.8.15 note/","content":"BFS对于同一个状态，宽度优先搜索只经过一次，因此复杂度为O(状态数*转移的方式)\nconst int INF &#x3D; 100000000;\ntypedef pair&lt;int, int&gt; P;\n\n&#x2F;&#x2F;输入\nchar maze[MAX_n][MAX_n+1];\nint N, M;\nint sx, sy;\nint gx, gy;\n\nint d[MAXN][MAXN];\n\nint dx[4] &#x3D; &#123;1,0,-1,0&#125;, dy [4]&#x3D; &#123;0,1,0,-1&#125;;\n\nint bfs()&#123;\n    queue&lt;P&gt; que;\n    for(int i &#x3D; 0; i &lt; N; ++i)\n        for(int j &#x3D; 0; j &lt; M; ++j) d[i][j] &#x3D; INF;\n        &#x2F;&#x2F;将起点加入队列，并把这一地点的距离设置为0；\n    que.push(P(sx, sy));\n    d[sx][sy] &#x3D; 0;\n\n    while(que.size())&#123;\n        P p &#x3D; que.front(); que.pop();\n\n        if(p.first &#x3D;&#x3D; gx &amp;&amp; p.second &#x3D;&#x3D; gy) break;\n        &#x2F;&#x2F;四个方向的循环\n        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n            int nx &#x3D; p.first + dx[i], ny &#x3D; p. second + dy[i];\n\n            if(0 &lt;&#x3D; nx &amp;&amp; nx &lt; N &amp;&amp; 0 &lt;&#x3D; ny &amp;&amp; ny &lt;&#x3D; M &amp;&amp; maze[nx][ny] !&#x3D; &#39;#&#39; &amp;&amp; d[nx][ny] &#x3D;&#x3D; INF)&#123;\n                que.push(P(nx, ny));\n                d[nx][ny] &#x3D; d[p.first][p.second] + 1;]\n            &#125;\n        &#125;\n    &#125;\n    return d[gx][gy];\n&#125;\n\nvoid solve()&#123;\n    int res &#x3D; bfs();\n    printf(&quot;%d\\n&quot;, res);\n &#125;","categories":["学习笔记"],"tags":[]},{"title":"学习笔记","url":"https://zzhy0616.github.io/2020/01/14/2020.8.14 note/","content":"Stack#include &lt;stack&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nint main()&#123;\n    stack&lt;int&gt; s;\n    s.push(1);\n    s.push(2);\n    s.push(3);\n    printf(&quot;%d\\n&quot;, s.top());\n    s.pop();\n    printf(&quot;%d\\n&quot;, s.top());\n    s.pop();\n    printf(&quot;%d\\n&quot;, s.top());\n    s.pop();\n    return 0;\n&#125;\n\nQueue#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nint main()&#123;\n    queue&lt;int&gt; que;\n    que.push(1);\n    que.push(2);\n    que.push(3);\n    printf(&quot;%d\\n&quot;, que.front());\n    que.pop();\n    printf(&quot;%d\\n&quot;, que.front());\n    que.pop();\n    printf(&quot;%d\\n&quot;, que.front());\n    que.poo();\n    return 0;\n&#125;\n\n深度优先搜索DFS简单来说就是一条路莽到底\n部分和问题\nint a[MAX_n];\nint n, k;\n\n&#x2F;&#x2F; 已经从前i项得到了和sum， 然后对于i项之后的进行分支\nbool dfs(int i, int sum)&#123;\n    &#x2F;&#x2F;如果前i项都计算过了则返回sum是否与k相等\n    if(i &#x3D;&#x3D; n) return sum &#x3D;&#x3D; k;\n    \n    &#x2F;&#x2F;不加上a[i]的情况\n    if(dfs(i + 1, sum)) return true;\n\n    &#x2F;&#x2F;加上a[i]的情况\n    if(dfs(i + 1, sum + a[i])) return true;\n\n    &#x2F;&#x2F;无论是否加上a[i]都不能凑成k就返回false\n    return false;\n&#125;\n\nvoid solve()&#123;\n    if(dfs(0,0)) printf(&quot;Yes\\n&quot;);\n    else printf(&quot;No\\n&quot;);\n&#125;\n","categories":["学习笔记"],"tags":[]},{"title":"队列","url":"https://zzhy0616.github.io/2020/01/14/队列/","content":"描述实现一个队列，完成以下功能：\n1.入列2.出列3.询问队列中位置Y是谁一开始队列为空。队列中的位置从1开始（即队头位置为1）。\n输入第一行一个整数n，表示操作个数。\n接下来n行，每行第一个数字表示操作（见描述）：\n若为数字1，则接下来有一串字符串X，表示将X加入队列。若为数字2，表示出列（保证队列非空），并输出出列的这个人。若为数字3，则接下来有一个整数Y，表示询问队列中位置Y是谁（保证位置Y合法），并输出名字。\n输出将所有操作2和操作3输出，一行一个\nSample Input111 a1 b1 c3 13 23 321 d3 13 23 3\nSample Outputabcabcd\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nstring Queue[100000];\nint head,tail;\nvoid enqueue(string name) &#123;\n    Queue[tail++] &#x3D; name;\n&#125;\nstring dequeue() &#123;\n    return Queue[head++];\n&#125;\nstring query(int pos) &#123;\n    return Queue[head + pos - 1];\n&#125;\nint main() &#123;\n    int n;\n    scanf(&quot;%d&quot;, &amp;n);\n    char name[20];\n    for (; n--; ) &#123;\n        int op;\n        scanf(&quot;%d&quot;, &amp;op);\n        if (op &#x3D;&#x3D; 1) &#123;\n            scanf(&quot;%s&quot;, name);\n            enqueue(name);\n        &#125; else if (op &#x3D;&#x3D; 2) &#123;\n            printf(&quot;%s\\n&quot;, dequeue().c_str());\n        &#125; else &#123;\n            int pos;\n            scanf(&quot;%d&quot;, &amp;pos);\n            printf(&quot;%s\\n&quot;, query(pos).c_str());\n        &#125;\n    &#125;\n    return 0;\n&#125;","categories":["基本数据结构"],"tags":[]},{"title":"高精度","url":"https://zzhy0616.github.io/2020/01/14/高精度/","content":"高精度加法 至此，就可以进行任意你想进行的运算了，首先我们来看看加法，其实上面的代码已经差不多写出来了。\n高精度加法Code\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;string&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint a[6666],b[6666],c[6666];\nint lena,lenb,lenc;\nchar s1[6666],s2[6666];\n \nint main()&#123;\n    scanf(&quot;%s %s&quot;,s1+1,s2+1);\n    lena&#x3D;strlen(s1+1);\n    lenb&#x3D;strlen(s2+1);\n    for(int i&#x3D;1;i&lt;&#x3D;lena;i++) a[i]&#x3D;s1[lena-i+1]-&#39;0&#39;;\n    for(int i&#x3D;1;i&lt;&#x3D;lenb;i++) b[i]&#x3D;s2[lenb-i+1]-&#39;0&#39;;\n    lenc&#x3D;max(lena,lenb);\n    for(int i&#x3D;1;i&lt;&#x3D;lenc;i++)&#123;\n        c[i]&#x3D;c[i]+a[i]+b[i];\n        c[i+1]&#x3D;c[i]&#x2F;10;\n        c[i]&#x3D;c[i]%10;\n    &#125;\n    while(c[lenc+1]&gt;0) lenc++;\n    for(int i&#x3D;lenc;i&gt;0;i--) printf(&quot;%d&quot;,c[i]);\n&#125;\n高精度减法高精度减法Code\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;string&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint a[6666],b[6666],c[6666];\nint lena,lenb,lenc;\nchar s1[6666],s2[6666];\n \nint main()&#123;\n    scanf(&quot;%s %s&quot;,s1+1,s2+1);\n    lena&#x3D;strlen(s1+1);\n    lenb&#x3D;strlen(s2+1);\n    if(lenb&gt;lena||(lena&#x3D;&#x3D;lenb&amp;&amp;s2&gt;s1))&#123;&#x2F;&#x2F;如果第二个数比第一个数大，那么结果是负数\n    \tprintf(&quot;-&quot;);\n    \tswap(s1,s2);&#x2F;&#x2F;swap是C++自带函数可以直接调用\n    \tswap(lena,lenb);&#x2F;&#x2F;别忘了交换长度\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;lena;i++) a[i]&#x3D;s1[lena-i+1]-&#39;0&#39;;\n    for(int i&#x3D;1;i&lt;&#x3D;lenb;i++) b[i]&#x3D;s2[lenb-i+1]-&#39;0&#39;;\n    lenc&#x3D;max(lena,lenb);\n    for(int i&#x3D;1;i&lt;&#x3D;lenc;i++)&#123;\n        c[i]&#x3D;c[i]+a[i]-b[i];\n        if(c[i]&lt;0) c[i]&#x3D;c[i]+10,c[i+1]&#x3D;-1;\n    &#125;\n    while(c[lenc]&#x3D;&#x3D;0&amp;&amp;lenc&gt;1) lenc--;\n    for(int i&#x3D;lenc;i&gt;0;i--) printf(&quot;%d&quot;,c[i]);\n&#125;\n\n高精度乘法高精度乘以单精度高精度乘以单精度Code\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;string&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint a[6666],b;\nint lena;\nchar s1[6666];\n \nint main()&#123;\n    scanf(&quot;%s %d&quot;,s1+1,&amp;b);\n    lena&#x3D;strlen(s1+1);\n    for(int i&#x3D;1;i&lt;&#x3D;lena;i++) a[i]&#x3D;s1[lena-i+1]-&#39;0&#39;;\n    for(int i&#x3D;1;i&lt;&#x3D;lena;i++) a[i]*&#x3D;b;\n    for(int i&#x3D;1;i&lt;&#x3D;lena;i++)&#123;\n    \ta[i+1]+&#x3D;a[i]&#x2F;10;\n    \ta[i]%&#x3D;10;\n    &#125;\n    while(a[lena+1]&gt;0) lena++;\n    for(int i&#x3D;lena;i&gt;0;i--) printf(&quot;%d&quot;,a[i]);\n&#125;\n\n高精度乘以高精度高精度乘以高精度Code\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;string&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint a[6666],b[6666],c[6666];\nint lena,lenb,lenc;\nchar s1[6666],s2[6666];\n \nint main()&#123;\n    scanf(&quot;%s %s&quot;,s1+1,s2+1);\n    lena&#x3D;strlen(s1+1);\n    lenb&#x3D;strlen(s2+1);\n    for(int i&#x3D;1;i&lt;&#x3D;lena;i++) a[i]&#x3D;s1[lena-i+1]-&#39;0&#39;;\n    for(int i&#x3D;1;i&lt;&#x3D;lenb;i++) b[i]&#x3D;s2[lenb-i+1]-&#39;0&#39;;\n    lenc&#x3D;lena+lenb-1;\n    for(int i&#x3D;1;i&lt;&#x3D;lena;i++)&#123;\n    \tfor(int j&#x3D;1;j&lt;&#x3D;lenb;j++)&#123;\n    \t\tc[i+j-1]+&#x3D;a[i]*b[j];\n    \t\tc[i+j]+&#x3D;c[i+j-1]&#x2F;10;\n    \t\tc[i+j-1]%&#x3D;10;\n\t\t&#125;\n\t&#125;\n    while(c[lenc+1]&gt;0) lenc++;\n    for(int i&#x3D;lenc;i&gt;0;i--) printf(&quot;%d&quot;,c[i]);\n&#125;\n高精度除法高精度除以单精度手动模拟一下，我们只要记录一个r，表示当前的余数，然后不断除就可以了。\n高精度除以单精度Code\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;string&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint a[6666],b,r;\nint lena;\nchar s1[6666];\n \nint main()&#123;\n    scanf(&quot;%s %d&quot;,s1+1,&amp;b);\n    lena&#x3D;strlen(s1+1);\n    for(int i&#x3D;1;i&lt;&#x3D;lena;i++) a[i]&#x3D;s1[lena-i+1]-&#39;0&#39;;\n    for(int i&#x3D;lena;i&gt;0;i--)&#123;\n    \tr&#x3D;r*10+a[i];\n    \ta[i]&#x3D;r&#x2F;b;\n    \tr&#x3D;r%b;\n    &#125;\n    while(a[lena]&#x3D;&#x3D;0&amp;&amp;lena&gt;1) lena--;\n    for(int i&#x3D;lena;i&gt;0;i--) printf(&quot;%d&quot;,a[i]);\n&#125;\n高精度除以高精度我们知道除法是乘法的逆运算，那么我们为什么不可以看做是我们现在要求一个数乘以除数等于被除数呢？那么枚举肯定是不行的，这个时候我们就要用到二分啦（二分大发好啊~），没错高精度二分商，实际上就是一个高精度加法（mid=l+r），然后高精度除以单精度（mid/2），最后再高精度减法（r=mid-1）就可以实现二分了，我们二分出来的数直接高精度乘以高精度判断一下就可以了（代码中数组中的第0个位置表示此数的长度，瞬间暴露PC党……）。\n高精度除以高精度Code\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;string&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint a[6666],b[6666],ans[6666],t[6666],l[6666],r[6666],mid[6666];\nchar s1[6666],s2[6666];\n \nint compare(int a[],int b[])&#123;\n    if(a[0]&gt;b[0]) return 0;\n    if(a[0]&lt;b[0]) return 1;\n    for(int i&#x3D;a[0];i&gt;0;i--)&#123;\n        if(a[i]&gt;b[i]) return 0;\n        if(a[i]&lt;b[i]) return 1;\n    &#125;\n    return 1;\n&#125;\n \nvoid add()&#123;\n    mid[0]&#x3D;max(l[0],r[0]);\n    for(int i&#x3D;1;i&lt;&#x3D;mid[0];i++) mid[i]&#x3D;l[i]+r[i];\n    while(mid[mid[0]+1]&gt;0) mid[0]++;\n    for(int i&#x3D;1;i&lt;&#x3D;mid[0];i++)&#123;\n        mid[i+1]+&#x3D;mid[i]&#x2F;10;\n        mid[i]%&#x3D;10;\n    &#125;\n    while(mid[mid[0]+1]&gt;0) mid[0]++;\n&#125;\n \nvoid times()&#123;\n    memset(t,0,sizeof(t));\n    t[0]&#x3D;b[0]+mid[0]-1;\n    for(int i&#x3D;1;i&lt;&#x3D;b[0];i++)&#123;\n        for(int j&#x3D;1;j&lt;&#x3D;mid[0];j++)&#123;\n            t[i+j-1]+&#x3D;b[i]*mid[j];\n            t[i+j]+&#x3D;t[i+j-1]&#x2F;10;\n            t[i+j-1]%&#x3D;10;\n        &#125;\n    &#125;\n    while(t[t[0]+1]&gt;0) t[0]++;\n&#125;\n \nvoid div()&#123;\n    int r&#x3D;0;\n    for(int i&#x3D;mid[0];i&gt;0;i--)&#123;\n        r&#x3D;r*10+mid[i];\n        mid[i]&#x3D;r&#x2F;2;\n        r%&#x3D;2;\n    &#125;\n    while(mid[mid[0]]&#x3D;&#x3D;0) mid[0]--;\n&#125;\n \nvoid left()&#123;\n    for(int i&#x3D;0;i&lt;&#x3D;mid[0];i++) l[i]&#x3D;ans[i]&#x3D;mid[i];\n    l[1]++;\n    for(int i&#x3D;1;i&lt;&#x3D;l[0];i++)&#123;\n        l[i+1]+&#x3D;l[i]&#x2F;10;\n        l[i]%&#x3D;10;\n    &#125;\n&#125;\n \nvoid right()&#123;\n    for(int i&#x3D;0;i&lt;&#x3D;mid[0];i++) r[i]&#x3D;mid[i];\n    r[1]--;\n    for(int i&#x3D;1;i&lt;&#x3D;r[0];i++)&#123;\n        if(r[i]&lt;0)&#123;\n            r[i+1]--;\n            r[i]+&#x3D;10;\n        &#125;\n    &#125;\n&#125;\n \nint main()&#123;\n    scanf(&quot;%s %s&quot;,s1+1,s2+1);\n    a[0]&#x3D;r[0]&#x3D;strlen(s1+1);\n    b[0]&#x3D;strlen(s2+1);\n    for(int i&#x3D;1;i&lt;&#x3D;a[0];i++) a[i]&#x3D;r[i]&#x3D;s1[a[0]-i+1]-&#39;0&#39;;\n    for(int i&#x3D;1;i&lt;&#x3D;b[0];i++) b[i]&#x3D;s2[b[0]-i+1]-&#39;0&#39;;\n    l[0]&#x3D;ans[0]&#x3D;1;\n    while(compare(l,r))&#123;\n        add();\n        div();\n        times();\n        if(compare(t,a)) left();\n        else right();\n    &#125;\n    for(int i&#x3D;ans[0];i&gt;0;i--) printf(&quot;%d&quot;,ans[i]);\n    return 0;\n&#125;\n高精度开平方没错，还是二分。二分答案。利用高精度加法和高精度除以单精度可以实现二分的效果，然后直接高精度乘法乘起来再高精度比较一下大小，再用高精度减法移动一下l和r就可以了。其实这也算是高精度比较综合的做法了。码量虽然惊人，但其实高精度除以高精度改一改就好了\n高精度开平方Code\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;string&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint a[6666],b[6666],ans[6666],t[6666],l[6666],r[6666],mid[6666];\nchar s1[6666],s2[6666];\n \nint compare(int a[],int b[])&#123;\n    if(a[0]&gt;b[0]) return 0;\n    if(a[0]&lt;b[0]) return 1;\n    for(int i&#x3D;a[0];i&gt;0;i--)&#123;\n        if(a[i]&gt;b[i]) return 0;\n        if(a[i]&lt;b[i]) return 1;\n    &#125;\n    return 1;\n&#125;\n \nvoid add()&#123;\n    mid[0]&#x3D;max(l[0],r[0]);\n    for(int i&#x3D;1;i&lt;&#x3D;mid[0];i++) mid[i]&#x3D;l[i]+r[i];\n    while(mid[mid[0]+1]&gt;0) mid[0]++;\n    for(int i&#x3D;1;i&lt;&#x3D;mid[0];i++)&#123;\n        mid[i+1]+&#x3D;mid[i]&#x2F;10;\n        mid[i]%&#x3D;10;\n    &#125;\n    while(mid[mid[0]+1]&gt;0) mid[0]++;\n&#125;\n \nvoid times()&#123;\n    memset(t,0,sizeof(t));\n    t[0]&#x3D;mid[0]+mid[0]-1;\n    for(int i&#x3D;1;i&lt;&#x3D;mid[0];i++)&#123;\n        for(int j&#x3D;1;j&lt;&#x3D;mid[0];j++)&#123;\n            t[i+j-1]+&#x3D;mid[i]*mid[j];\n            t[i+j]+&#x3D;t[i+j-1]&#x2F;10;\n            t[i+j-1]%&#x3D;10;\n        &#125;\n    &#125;\n    while(t[t[0]+1]&gt;0) t[0]++;\n&#125;\n \nvoid div()&#123;\n    int r&#x3D;0;\n    for(int i&#x3D;mid[0];i&gt;0;i--)&#123;\n        r&#x3D;r*10+mid[i];\n        mid[i]&#x3D;r&#x2F;2;\n        r%&#x3D;2;\n    &#125;\n    while(mid[mid[0]]&#x3D;&#x3D;0) mid[0]--;\n&#125;\n \nvoid left()&#123;\n    for(int i&#x3D;0;i&lt;&#x3D;mid[0];i++) l[i]&#x3D;ans[i]&#x3D;mid[i];\n    l[1]++;\n    for(int i&#x3D;1;i&lt;&#x3D;l[0];i++)&#123;\n        l[i+1]+&#x3D;l[i]&#x2F;10;\n        l[i]%&#x3D;10;\n    &#125;\n&#125;\n \nvoid right()&#123;\n    for(int i&#x3D;0;i&lt;&#x3D;mid[0];i++) r[i]&#x3D;mid[i];\n    r[1]--;\n    for(int i&#x3D;1;i&lt;&#x3D;r[0];i++)&#123;\n        if(r[i]&lt;0)&#123;\n            r[i+1]--;\n            r[i]+&#x3D;10;\n        &#125;\n    &#125;\n&#125;\n \nint main()&#123;\n    scanf(&quot;%s&quot;,s1+1);\n    a[0]&#x3D;r[0]&#x3D;strlen(s1+1);\n    for(int i&#x3D;1;i&lt;&#x3D;a[0];i++) a[i]&#x3D;r[i]&#x3D;s1[a[0]-i+1]-&#39;0&#39;;\n    l[0]&#x3D;ans[0]&#x3D;1;\n    while(compare(l,r))&#123;\n        add();\n        div();\n        times();\n        if(compare(t,a)) left();\n        else right();\n    &#125;\n    for(int i&#x3D;ans[0];i&gt;0;i--) printf(&quot;%d&quot;,ans[i]);\n    return 0;","categories":[],"tags":[]},{"title":"排序 Sorting","url":"https://zzhy0616.github.io/2020/01/10/排序 Sorting/","content":"Gnomesort: Naive + ImprovednaiveGnomesort(s[], n) &#x2F;&#x2F;single loop but O(n^2)\n  for(int i &#x3D; 1; i &lt; n; )&#123;\n      if(i &lt; 1 || s[i-1] &lt;&#x3D; s[i]) &#x2F;&#x2F;GREEDY\n      i++;&#x2F;&#x2F;inefficient backtracking\n      else \n        &#123;  \n            swap ( s[ i-1], s[i]);\n            i--;\n        &#125;\n  &#125;\nimproveGnomesort(s[], n)&#x2F;&#x2F;nested loops and still o(n^2) \n&#123;\nfor(int k &#x3D; 1; k &lt; n ; k++) &#x2F;&#x2F;Since s[0,k) is always sorted, we can\n  for(int i &#x3D; k; 0 &lt; i &amp;&amp; s[i-1] &gt; s[i]; i-- ) &#x2F;&#x2F;backtrack to k and rescan\n    swap( s[i-1], s[i]);\n&#125;\n\n\nBubblesort: Basictemplate &lt;typename T&gt; \nvoid Vector&lt;T&gt;:: bubbleSort ( Rank lo, Rank hi)&#123;\n  while( lo &lt; hi)\n  bubble( lo, hi--);&#x2F;&#x2F;逐趟做扫描交换\n&#125;\ntemplate &lt;typename T&gt; \nvoid Vector&lt;T&gt;:: bubble( Rank lo, Rank hi)&#123;\n  while(++lo &lt; hi)&#123;&#x2F;&#x2F;从左向右，逐一检查各对相邻元素\n    if( _elem[lo-1] &gt; _elem[lo] )&#x2F;&#x2F;若逆序\n      swap( _elem[lo-1], _elem[lo]);&#x2F;&#x2F;交换\n  &#125;\n&#125; \nBubblesort: 提前终止template &lt;typename T&gt; \nvoid Vector&lt;T&gt;:: bubbleSort ( Rank lo, Rank hi)&#123;\n  while( ! bubble( lo, hi--))&#x2F;&#x2F;逐趟做扫描交换\n&#125;\ntemplate &lt;typename T&gt; \nbool Vector&lt;T&gt;:: bubble( Rank lo, Rank hi)&#123;\n  bool sorted &#x3D; true;\n  while(++lo &lt; hi)&#123;&#x2F;&#x2F;从左向右，逐一检查各对相邻元素\n    if( _elem[lo-1] &gt; _elem[lo] )&#123;&#x2F;&#x2F;若逆序\n      sorted &#x3D; false;\n      swap( _elem[lo-1], _elem[lo]);&#x2F;&#x2F;交换\n  &#125;\n  return sorted;&#x2F;&#x2F;整体有序\n&#125; \nBubblesort: 跳过无效起泡template &lt;typename T&gt; \nvoid Vector&lt;T&gt;:: bubbleSort ( Rank lo, Rank hi)&#123;\n  while( lo &lt; ( hin &#x3D; bubble( lo, hi)))&#x2F;&#x2F;逐趟做扫描交换,直至全序\n&#125;\ntemplate &lt;typename T&gt; \nbool Vector&lt;T&gt;:: bubble( Rank lo, Rank hi)&#123;\n  Rank last &#x3D; lo;\n  while(++lo &lt; hi)&#123;&#x2F;&#x2F;从左向右，逐一检查各对相邻元素\n    if( _elem[lo-1] &gt; _elem[lo] )&#123;&#x2F;&#x2F;若逆序\n      last &#x3D; lo;&#x2F;&#x2F;更新最右侧逆序对位置记录，并\n      swap( _elem[lo-1], _elem[lo]);&#x2F;&#x2F;交换\n  &#125;\n  return last;&#x2F;&#x2F;逆序对均在last以左\nSelection Sorttemplate &lt;typename T,int size&gt;\nvoid sort(T(&amp;array)[size])&#x2F;&#x2F;数组排序模版\n&#123;\n    for(int i&#x3D;0;i&lt;size;i++)&#x2F;&#x2F;从第一个开始遍历数组size次，默认将第一个视为最小元素；\n    &#123;\n        T min&#x3D;array[i];&#x2F;&#x2F;暂时将当前元素当作最小值\n        int k&#x3D;i;&#x2F;&#x2F;记录当前地址\n        for(int j&#x3D;i+1;j&lt;size;j++)&#x2F;&#x2F;遍历未排序元素\n        &#123;\n            if(array[j]&lt;min)&#x2F;&#x2F;如果未排序元素中有比当前值还小的\n            &#123;\n                min&#x3D;array[j];&#x2F;&#x2F;更新最小值\n                k&#x3D;j;&#x2F;&#x2F;更新最小值地址\n            &#125;\n        &#125;\n        if(k!&#x3D;i)&#x2F;&#x2F;当一遍循环结束后如果最小元素不是当前值，将最小元素与当前值进行交换\n        &#123;\n            array[k]&#x3D;array[i];\n            array[i]&#x3D;min;\n\n        &#125;\n    &#125;\n&#125;\n————————————————\n版权声明：本文为CSDN博主「liqiluan」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_39352109&#x2F;article&#x2F;details&#x2F;88378108\n\nQuickSelecttemplate &lt;typename T&gt; void quickSelect( Vector&lt;T&gt; &amp; A, Rank k)&#123;\n  for(Rank lo &#x3D; 0, hi &#x3D; A.size() -  1; lo &lt; hi; )&#123;\n    Rank i &#x3D; lo, j &#x3D; hi; T pivot &#x3D; A[lo];\n    while(i &lt; j)&#123;\n      while( pivot &lt;&#x3D; A[j] )&#123; j--; A[i] &#x3D; A[j];&#125;\n      while( A[i] &lt;&#x3D; pivot ) &#123; i++; A[j] &#x3D; A[i];&#125;\n    &#125;\n    A[i] &#x3D; pivot;\n    if( k &lt;&#x3D; i ) hi &#x3D; i - 1;\n    if( i &lt;&#x3D; k ) lo &#x3D; i + 1;\n  &#125;\n&#125;\n归并排序#include&lt;stdio.h&gt;\nusing namespace std;\nint a[100001],temp[100001];\n\nvoid bin(int l,int r)\n&#123;\n    if(l&#x3D;&#x3D;r) return ;\n    int mid&#x3D;(l+r)&gt;&gt;1;\n    bin(l,mid);\n    bin(mid+1,r);\n    int i&#x3D;l,j&#x3D;mid+1,k&#x3D;l;\n    while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;r) \n    &#123;\n        if(a[i]&lt;&#x3D;a[j]) &#123;\n            temp[k]&#x3D;a[i];\n            k++,i++;\n        &#125;\n        else \n        &#123;\n            temp[k]&#x3D;a[j];\n            k++,j++;\n        &#125;\n    &#125;\n    \n    while(i&lt;&#x3D;mid)\n    &#123;\n        temp[k]&#x3D;a[i];\n        k++,i++;\n    &#125;\n    while(j&lt;&#x3D;r)\n    &#123;\n        temp[k]&#x3D;a[j];\n        k++,j++;\n    &#125;\n    for(int i&#x3D;l;i&lt;&#x3D;r;++i)&#123;\n        a[i]&#x3D;temp[i];\n    &#125;\n&#125;\n\nint main()\n&#123;\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        scanf(&quot;%d&quot;,&amp;a[i]);\n    &#125;\n    bin(1,n);\n    for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        printf(&quot;%d &quot;,a[i]);\n    &#125;\n    return 0;\n&#125;\n&#x2F;&#x2F;原文地址：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;qseer&#x2F;p&#x2F;9419949.html\n计数排序#include&lt;iostream&gt;\n#include&lt;time.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;stdio.h&gt;\nusing namespace std;\n#define range 10000\nvoid CountingSort(int a[],int b[],int len)\n&#123;\n\tint cnt&#x3D;0;\n\tfor(int i&#x3D;0;i&lt;len;i++)\n\t&#123;\n\t\tb[a[i]]++;\n\t&#125;\n\tfor(int i&#x3D;0;i&lt;len;i++)\n\twhile(b[i]!&#x3D;0)\n\t&#123;\n\t\ta[cnt++]&#x3D;i;\n\t\tb[i]--;\n\t&#125;\n&#125;\n \nint main()\n&#123;\n\tclock_t start,end;\n\tstart&#x3D;clock();\n\tfreopen(&quot;out_arr.txt&quot;,&quot;r&quot;,stdin);\n\tfreopen(&quot;out_计数排序.txt&quot;,&quot;w&quot;,stdout);\n\tint a[range],b[range]&#x3D;&#123;0&#125;;\n\tfor(int i&#x3D;0;i&lt;range;i++)\n\t&#123;\n\t\tscanf(&quot;%d&quot;,&amp;a[i]);\n\t&#125;\n\tCountingSort(a,b,range);\n\tfor(int i&#x3D;0;i&lt;range;i++)\n\t&#123;\n\t\tprintf(&quot;%5d &quot;,a[i]);\n\t\tif((i+1)%50&#x3D;&#x3D;0)\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n\tend&#x3D;clock();\n\tprintf(&quot;计数排序耗时：%dms\\n&quot;,(float)(end-start)*1000.0&#x2F;CLOCKS_PER_SEC);\n\t\n\t\n\t\n\t\n\treturn 0;\n\n————————————————\n版权声明：本文为CSDN博主「生于忧患，死于安乐2017」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41325698&#x2F;article&#x2F;details&#x2F;88095563","categories":[],"tags":[]},{"title":"木块问题","url":"https://zzhy0616.github.io/2020/01/09/木块问题/","content":"输入n，得到编号为0 —- n-1的木块，分别摆放在顺序排列编号为0 – n-1的位置。现对这些木块进行操作，操作分为四种。\n1、move a onto b：把木块a、b上方的木块放回各自的原位，再把a放到b上；\n2、move a over b：把a上方的木块放回各自的原位，再把a放到b所在的木块的堆的上面；\n3、pile a onto b：把b上方的木块放回各自的原位，再把a连同a上的木块整体移到b上；\n4、pile a over b：把a连同a上方木块移到b所在的木块的堆的上面。\n当输入quit时，结束操作并输出0~n-1的位置上的木块情况\nSample Input10move 9 onto 1move 8 over 1move 7 over 1move 6 over 1pile 8 over 6pile 8 over 5move 2 over 1move 4 over 9quit\nSample Output0: 01: 1 9 2 42:3: 34:5: 5 8 7 66:7:8:9:\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nconst int maxn &#x3D; 30;\nint n;\nvector&lt;int&gt; pile[maxn];\n\n\n&#x2F;&#x2F;找木块a所在的pile和height， 以引用的形式返回调用者\nvoid find_block(int a, int&amp; p, int&amp; h) &#123;\n\tfor ( p &#x3D; 0; p &lt; n; p++)\n\t\tfor ( h &#x3D; 0; h &lt; pile[p].size(); h++)\n\t\t\tif (pile[p][h] &#x3D;&#x3D; a) return;\n&#125;\n\n&#x2F;&#x2F;把第p堆高度为h的木块上方的所有木块移回原位置\nvoid clear_above(int p, int h) &#123;\n\tfor (int i &#x3D; h + 1; i &lt; pile[p].size(); i++) &#123;\n\t\tint b &#x3D; pile[p][i];\n\t\tpile[b].push_back(b);\n\t&#125;\n\tpile[p].resize(h + 1); &#x2F;&#x2F;只保留下标0~h的元素  .resize()改变大小\n&#125;\n\n&#x2F;&#x2F;把第p堆高度为h及其上方的木块整体移动到p2堆的顶部\nvoid pile_onto(int p, int h, int p2) &#123;\n\tfor (int i &#x3D; h; i &lt; pile[p].size(); i++)\n\t\tpile[p2].push_back(pile[p][i]);\n\tpile[p].resize(h);\n&#125;\n\n\nvoid print() &#123;\n\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\tprintf(&quot;%d:&quot;, i);\n\t\tfor (int j &#x3D; 0; j &lt; pile[i].size(); j++) printf(&quot; %d&quot;, pile[i][j]);\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\nint main() &#123;\n\tint a, b;\n\tcin &gt;&gt; n;\n\tstring s1, s2;\n\tfor (int i &#x3D; 0; i &lt; n; i++) pile[i].push_back(i);\n\twhile (cin &gt;&gt; s1 &gt;&gt; a &gt;&gt; s2 &gt;&gt; b) &#123;\n\t\tint pa, pb, ha, hb;\n\t\tfind_block(a, pa, ha);\n\t\tfind_block(b, pb, hb);\n\t\tif (pa &#x3D;&#x3D; pb) continue;\n\t\tif (s2 &#x3D;&#x3D; &quot;onto&quot;) clear_above(pb, hb);\n\t\tif (s1 &#x3D;&#x3D; &quot;move&quot;) clear_above(pa, ha);\n\t\tpile_onto(pa, ha, pb);\n\t&#125;\n\tprint();\n\treturn 0;\n&#125;","categories":[],"tags":["STL"]}]