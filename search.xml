<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>搜索集合</title>
      <link href="2020/11/07/%E6%90%9C%E7%B4%A2%E9%9B%86%E5%90%88-1/"/>
      <url>2020/11/07/%E6%90%9C%E7%B4%A2%E9%9B%86%E5%90%88-1/</url>
      
        <content type="html"><![CDATA[<h2 id="特殊状态的枚举"><a href="#特殊状态的枚举" class="headerlink" title="特殊状态的枚举"></a>特殊状态的枚举</h2><p>关于函数next_pumutation，可以把n个元素共n！种排列枚举出来</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool  used[MAX_N];int perm[MAX_N];&#x2F;&#x2F;生成&#123;0， 1， 2 ，3， 4 ，... n- 1&#125; 的 n！序列void permutation(int pos , int n)&#123;    if(pos &#x3D;&#x3D; n) &#123;        &#x2F;*        对perm进行的操作        *&#x2F;    return ;    &#125;    for(int i &#x3D; 0; i&lt; n; ++i) &#123;        if(!used[i])&#123;            perm[pos] &#x3D; i;            used[i] &#x3D; true;            permutation(pos + 1, n);            used[i] &#x3D; false;        &#125;    &#125;    return ;&#125;#include &lt;algorithm&gt;int perm2[MAX_N];&#x2F;&#x2F; 按字典序生成下一个序列void permutation (int n)&#123;     for(int i &#x3D; 0; i &lt; n; ++i) &#123;        perm2 [i]   &#x3D;  i;    &#125;    do &#123;    &#125;    while(next_permutation(perm2, perm2 + n));    return ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Descriptions"><a href="#Descriptions" class="headerlink" title="Descriptions:"></a>Descriptions:</h2><p>给定若干位十进制数，你可以通过选择一个非空子集并以某种顺序构建一个数。剩余元素可以用相同规则构建第二个数。除非构造的数恰好为0，否则不能以0打头。 </p><p>举例来说，给定数字0，1，2，4，6与7，你可以写出10和2467。当然写法多样：210和764，204和176，等等。最后一对数差的绝对值为28，实际上没有其他对拥有更小的差。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入第一行的数表示随后测试用例的数量。<br>对于每组测试用例，有一行至少两个不超过10的十进制数字。（十进制数字为0，1，…，9）每行输入中均无重复的数字。数字为升序给出，相隔恰好一个空格。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每组测试用例，输出一个以上述规则可获得的最小的差的绝对值在一行。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1<br>0 1 2 4 6 7</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>28</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>所需数字需要绝对值最小，即两个数字的数位相似，故枚举即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;fstream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;deque&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;sstream&gt;using namespace std;int num[1005];int q;int ans;const int INF &#x3D; 100010 + 7;void solve()&#123;    while(q--)&#123;        int len &#x3D; 0;        char ch;        while(1)&#123;            scanf(&quot;%d%c&quot;, &amp;num[len++], &amp;ch);            if(ch &#x3D;&#x3D; &#39;\n&#39;)                break;        &#125;        if(len &#x3D;&#x3D; 2)&#123;            printf(&quot;%d\n&quot;, abs(num[0]- num[1]));            continue;        &#125;        int n1, n2;        ans &#x3D; INF;        int mid &#x3D; len &#x2F;2;        do&#123;            n1 &#x3D; num[0], n2 &#x3D; num[mid];            if(n1 &#x3D;&#x3D; 0 || n2 &#x3D;&#x3D; 0)                continue;            for(int i &#x3D; 1; i &lt; mid; ++i)             n1 &#x3D; n1 * 10 + num[i];            for(int i &#x3D; mid + 1; i &lt; len; ++i)                n2 &#x3D; n2 *10 + num[i];            ans &#x3D; min(ans, abs(n1 - n2));        &#125;                while(next_permutation(num, num + len));        cout &lt;&lt; ans &lt;&lt; endl;    &#125;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;q);    solve();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/11/07/%E6%90%9C%E7%B4%A2%E9%9B%86%E5%90%88/"/>
      <url>2020/11/07/%E6%90%9C%E7%B4%A2%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MST</title>
      <link href="2020/09/20/MST/"/>
      <url>2020/09/20/MST/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unionfind</title>
      <link href="2020/09/20/unionfind/"/>
      <url>2020/09/20/unionfind/</url>
      
        <content type="html"><![CDATA[<p>经典并查集题目<br>find（）和union操作</p><hr><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int  N &#x3D; 300005;int Father[N], Rank[N];&#x2F;&#x2F;Father节点数据， Rank树的大小&#x2F;&#x2F; 递归find操作int find(int x)&#123;    if(Father[x] &#x3D;&#x3D; x)&#123;        return x;    &#125; else &#123;        return Father[x] &#x3D; find(Father[x]);    &#125;&#125;string getAnswer(int n, int m, vector&lt;int&gt; A, vector&lt;int&gt; B, vector&lt;int&gt; E) &#123;    &#x2F;&#x2F;初始化    for(int i &#x3D; 0; i &lt;&#x3D; n; ++i)&#123;        Father[i] &#x3D; i;        Rank[i] &#x3D; 0;    &#125;    &#x2F;&#x2F;排序使1操作位于前    int cnt &#x3D; 0;    for(int i &#x3D; 0; i &lt; m ; ++i)&#123;        if(E[i] &#x3D;&#x3D; 1)&#123;            swap(E[i], E[cnt]);            swap(A[i], A[cnt]);            swap(B[i], B[cnt]);            cnt++;        &#125;    &#125;    &#x2F;&#x2F;union操作    for(int i &#x3D; 0; i &lt; m; ++i)&#123;        int setA &#x3D; find(A[i]);        int setB &#x3D; find(B[i]);        if(E[i] &#x3D;&#x3D; 0)&#123;            if(setA &#x3D;&#x3D; setB)            return &quot;No&quot;;        &#125;else &#123;            if(setA !&#x3D; setB)&#123;                &#x2F;&#x2F;使小树加入大树                if(Rank[setB] &lt; Rank[setA])                    swap(setA, setB);                Father[setA] &#x3D; setB;                if(Rank[setA] &#x3D;&#x3D; Rank[setB])                    Rank[setA]++;                       &#125;        &#125;    &#125;    return &quot;Yes&quot;;&#125;int main() &#123;    int T;    for (scanf(&quot;%d&quot;, &amp;T); T--; ) &#123;        int n, m;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        vector&lt;int&gt; A, B, E;        for (int i &#x3D; 0; i &lt; m; ++i) &#123;            int a, b, e;            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;e);            A.push_back(a);            B.push_back(b);            E.push_back(e);        &#125;        printf(&quot;%s\n&quot;, getAnswer(n, m, A, B, E).c_str());    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hash</title>
      <link href="2020/09/20/Hash/"/>
      <url>2020/09/20/Hash/</url>
      
        <content type="html"><![CDATA[<p>哈希题目</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int Mod &#x3D; 1000003;vector&lt;ll&gt; table[Mod];int Hash(ll x)&#123;    return x  % Mod; &#125;&#x2F;&#x2F;hash操作bool check(int op, ll x) &#123;    int h &#x3D; Hash(x);    &#x2F;&#x2F;初始化    vector&lt;ll&gt;:: iterator ptr &#x3D; table[h].end();    for(vector&lt;ll&gt;::iterator it &#x3D; table[h].begin(); it !&#x3D; table[h].end(); ++it)      if(*it &#x3D;&#x3D; x)&#123;          ptr &#x3D; it;          break;      &#125;&#x2F;&#x2F;找到元素的位置    if(op &#x3D;&#x3D; 1)&#123;        if(ptr &#x3D;&#x3D; table[h].end())&#123;            table[h].push_back(x);            &#x2F;&#x2F;濡傛灉婊¤冻鍒檟涓嶅瓨鍦?            return 1;        &#125;        return 0;    &#125; else &#123;        if(ptr !&#x3D; table[h].end())&#123;            *ptr &#x3D; table[h].back();            table[h].pop_back();            return 1;        &#125;        return 0;    &#125;&#125;&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 盲禄拢莽聽聛氓庐啪莽沤掳莽禄鈥溍β澟?&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;int main() &#123;    int Q, op;    ll x;    scanf(&quot;%d&quot;, &amp;Q);    while (Q--) &#123;        scanf(&quot;%d%lld&quot;, &amp;op, &amp;x);        puts(check(op, x) ? &quot;Succeeded&quot; : &quot;Failed&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Huffuman</title>
      <link href="2020/09/20/Huffuman/"/>
      <url>2020/09/20/Huffuman/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="2020/09/20/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2020/09/20/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 100005;struct node &#123;int val, l, r;&#125; t[N];int root, cnt;&#x2F;&#x2F;ÔÚÒÔxÎª¸ùµÄÊ÷ÖÐ²åÈëÒ»¸öÊý×Öv&#x2F;&#x2F;v:Òª²åÈëµÄÊý×Ö&#x2F;&#x2F;x£ºµ±Ç°½Úµã&#x2F;&#x2F;·µ»ØÖµ£ºx int insert(int v, int x)&#123;if(x &#x3D;&#x3D; 0)&#123;x &#x3D; ++cnt;t[x].val &#x3D; v;t[x].r &#x3D; 0;t[x].l &#x3D; 0;return x;&#125;if(t[x].val &gt; v)t[x].l &#x3D; insert(v, t[x].l);else t[x].r            veturn x;&#125;void dlr(int x, vector&lt;int&gt; &amp;ans)&#123;if(x)&#123;ans.push_back(t[x].val);dlr(t[x].l,ans);dlr(t[x].r,ans);&#125;&#125;int lrd(int x, vector&lt;int&gt; &amp;ans)&#123;if(x)&#123;lrd(t[x].l,ans);lrd(t[x].r,ans);ans.push_back(t[x].val);&#125;&#125;&#x2F;&#x2F;¿É¼Ç×ö¸ù×óÓÒ¡£Ç°Ðò±éÀúÊ×ÏÈ·ÃÎÊ¸ù½áµãÈ»ºó±éÀú×ó×ÓÊ÷£¬×îºó±éÀúÓÒ×ÓÊ÷¡£ vector&lt;int&gt; getAnswer(int n, vector&lt;int&gt; sequence) &#123;root &#x3D; cnt &#x3D; 0;for(int i &#x3D; 0; i &lt; int(sequence.size()); ++i)&#123;root &#x3D; insert(sequence[i], root);&#125;vector&lt;int&gt; ans;dlr(root, ans);lrd(root, ans);return ans;&#125;int main() &#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    vector&lt;int&gt; sequence;    for (int i &#x3D; 0; i &lt; n; ++i) &#123;        int x;        scanf(&quot;%d&quot;, &amp;x);        sequence.push_back(x);    &#125;    vector&lt;int&gt; ans &#x3D; getAnswer(n, sequence);    for (int i &#x3D; 0; i &lt; n; ++i)        printf(&quot;%d%c&quot;, ans[i], &quot; \n&quot;[i &#x3D;&#x3D; n - 1]);    for (int i &#x3D; 0; i &lt; n; ++i)        printf(&quot;%d%c&quot;, ans[n + i], &quot; \n&quot;[i &#x3D;&#x3D; n - 1]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TO DO LIST</title>
      <link href="2020/08/21/TO-DO-LIST/"/>
      <url>2020/08/21/TO-DO-LIST/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>April week 1题单</title>
      <link href="2020/03/27/April-week-1%E6%8F%90%E5%8D%95/"/>
      <url>2020/03/27/April-week-1%E6%8F%90%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://www.luogu.com.cn/problem/P2249">P2249 【深基13.例1】查找</a></li><li><a href="https://www.luogu.com.cn/problem/P1102">P1102 A-B 数对</a></li><li><a href="https://www.luogu.com.cn/problem/P1873">P1873 砍树</a></li><li><a href="https://www.luogu.com.cn/problem/P1024">P1024 一元三次方程求解</a></li><li><a href="https://www.luogu.com.cn/problem/P1678">P1678 烦恼的高考志愿</a></li><li><a href="https://www.luogu.com.cn/problem/P2440">P2440 木材加工</a></li><li><a href="https://www.luogu.com.cn/problem/P3853">P3853 [TJOI2007]路标设置</a></li><li><a href="https://www.luogu.com.cn/problem/P1163">P1163 银行贷款</a></li><li><a href="https://www.luogu.com.cn/problem/P3743">P3743 kotori的设备</a></li><li>象棋</li><li>序列计数</li><li>最小交换</li><li>楼尔邦德<br>完成情况(1/13)</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="2020/02/05/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>2020/02/05/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>符号</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td><td>两个位都为1时，结果才为1</td></tr><tr><td>|</td><td>或</td><td>两个位都为0时，结果才为0</td></tr><tr><td>^</td><td>异或</td><td>两个位相同为0，相异为1</td></tr><tr><td>~</td><td>非</td><td>0变1，1变0</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>各二进位全部左移若干位，高位丢弃，低位补0</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二分答案 分组</title>
      <link href="2020/02/03/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E5%88%86%E7%BB%84/"/>
      <url>2020/02/03/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>有n个正整数排成一排，你要将这些数分成m份（同一份中的数字都是连续的，不能隔开），同时数字之和最大的那一份的数字之和尽量小。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入的第一行包含两个正整数n，m。</p><p>接下来一行包含n个正整数。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出一个数，表示最优方案中，数字之和最大的那一份的数字之和。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">include &lt;bits&#x2F;stdc++.h&gt;using namespace std;&#x2F;&#x2F;判断数组a是否能分成不超过m份， 满足每份都不超过d&#x2F;&#x2F; n:数组a的大小&#x2F;&#x2F;返回值：若能分成不超过m份， 返回true， 否则返回falsebool check(long long d, int n, int m, vector&lt;int&gt; &amp;a)&#123;    long long sum &#x3D; 0; &#x2F;&#x2F;记录当前一份数字的和    int cnt &#x3D; 1;&#x2F;&#x2F;在每一份数字之和不超过d的情况下，至少要分成的份数    for( int i &#x3D; 0; i &lt; n; i++)&#123;        if(a[i] &gt; d) &#x2F;&#x2F; 如果单个元素超过d， 直接结束返回false           return false;                sum +&#x3D; a[i];&#x2F;&#x2F; 将a[i]加入当前这一份中        if(sum &gt; d)&#123;            sum &#x3D; a[i];            ++cnt;        &#125; &#x2F;&#x2F;加入a[i]后，若超过d，至少分成的数加一    &#125;    return cnt &lt;&#x3D; m; &#125;long long getAnswer(int n, int m, vector&lt;int&gt; a) &#123;    &#x2F;&#x2F; l表示答案的下界，r表示答案的上界    long long l &#x3D; 1, r &#x3D; 0;   &#x2F;&#x2F;求出答案的上界    for(int i &#x3D; 0; i &lt; n; i++)&#123;        r +&#x3D; a[i];    &#125;   &#x2F;&#x2F; 二分答案    while(l &lt;&#x3D; r)&#123;        long long mid &#x3D; (l + r) &gt;&gt; 1;        if(check(mid, n , m, a))            r &#x3D; mid - 1;        else             l &#x3D; mid + 1;    &#125;    return  r + 1; &#125;int main() &#123;    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    vector&lt;int&gt; a;    a.resize(n);    for (int i &#x3D; 0; i &lt; n; ++i)        scanf(&quot;%d&quot;, &amp;a[i]);    printf(&quot;%lld\n&quot;, getAnswer(n, m, a));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="2020/01/17/%E9%93%BE%E8%A1%A8/"/>
      <url>2020/01/17/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>链表可以使用结构体来存储 struct slist {int prev, value, next;}list[enough];<br>也可以直接使用若干个数组来实现<br>int prev[enough], value[enough], next[enough]; </p><pre><code class="c++">int del(int x) &#123; // 删除链表中的 x next[prev[x]] = next[x]; prev[next[x]] = prev[x]; &#125;int ins(int x, int y) &#123; // 在 x 的右边 (next) 插入y prev[next[x]] = y; next[y] = next[x]; next[x] = y; prev[y] = x;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="2020/01/17/STL/"/>
      <url>2020/01/17/STL/</url>
      
        <content type="html"><![CDATA[<h2 id="pair-结构体"><a href="#pair-结构体" class="headerlink" title="pair 结构体"></a>pair 结构体</h2><p>▶ 可以将两种类型融合成一种类型<br>▶ 就比如一个区间可以用两个端点表示，例如区间 [1,3] pair&lt;int, int&gt; range; range.first = 1, range.second = 3;<br>▶ 可以是不同的类型，就比如一个人有学号 12，得分 99.2 pair&lt;int, double&gt; p; p.first = 12, p.second = 99.2;<br>▶ 不难发现，使用 pair 应该将两种类型放到尖括号内，前一种类 型为 first，后一种为 second<br>▶ 可以用括号赋值，只能在定义的时用<br>pair&lt;int, char&gt; q(3, ‘a’); // 正确<br>q(4, ‘b’); // 错误，只能定义时用</p><h3 id="make-pair函数"><a href="#make-pair函数" class="headerlink" title="make_pair函数"></a>make_pair函数</h3><p>可以将两个数融合成一个pair<br>pair&lt;int, int&gt; s = make_pair(2, 3); </p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>先比较first 再比较second</p><h2 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h2><p>▶ a[15] = {9, 2, 3, 1, 4, 3, 6, 5, 2, 10};<br>▶ 从小到大排序 sort(a, a + 10);<br>▶ 从大到小排序 sort(a, a + 10, greater<int>());<br>▶ 使用 greater 可能需要 #include <functional><br>▶ sort 函数前两个参数是地址，记为 l,r，排序的区间为 [l,r)<br>▶ 有 n 个区间 (l[i], r[i])，将这 n 个区间以左端点为第一关键 字，右端点按第二关键字从小到大排序<br>pair&lt;int, int&gt; range[enough]; for(int i = 1; i &lt;= n; ++i) range[i] = make_pair(l[i], r[i]); sort(range + 1, range + n + 1);<br>▶ 有 n 个区间 (l[i], r[i])，将这 n 个区间以左端点为第一关键 字，右端点按第二关键字且左端点递增，右端点递减排序<br>pair&lt;int, int&gt; range[enough]; for(int i = 1; i &lt;= n; ++i) range[i] = make_pair(l[i], -r[i]); sort(range + 1, range + n + 1);</p><h2 id="unique-去重函数"><a href="#unique-去重函数" class="headerlink" title="unique 去重函数"></a>unique 去重函数</h2><p>先排序，然后把相邻的相同元素删掉<br>sort(a + 1, a + n + 1);<br>n = unique(a + 1, a + n + 1) - a - 1; </p><h2 id="lower-bound-upper-bound-函数"><a href="#lower-bound-upper-bound-函数" class="headerlink" title="lower_bound, upper_bound 函数"></a>lower_bound, upper_bound 函数</h2><p>lower_bound(l, r, v) 可以得到在 [l,r) 内第一个大于等于 v 的 位置<br>upper_bound(l, r, v) 可以得到在 [l,r) 内第一个大于 v 的位置 </p><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>priority_queue 可以快速的支持插入，查找最大值，删除最大值 的操作</p><h3 id="定义一个-priority-queue"><a href="#定义一个-priority-queue" class="headerlink" title="定义一个 priority_queue"></a>定义一个 priority_queue</h3><p>priority_queue<int> que; </p><h3 id="插入一个-x"><a href="#插入一个-x" class="headerlink" title="插入一个 x"></a>插入一个 x</h3><p>que.push(x); </p><h3 id="查找最大值"><a href="#查找最大值" class="headerlink" title="查找最大值"></a>查找最大值</h3><p>maxvalue = que.top();</p><h3 id="删除最大值"><a href="#删除最大值" class="headerlink" title="删除最大值"></a>删除最大值</h3><p>que.pop();</p><h3 id="定义最小"><a href="#定义最小" class="headerlink" title="定义最小"></a>定义最小</h3><p>priority_queue&lt;int, vector<int>, greater<int> &gt; q </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Binary</title>
      <link href="2020/01/14/Binary/"/>
      <url>2020/01/14/Binary/</url>
      
        <content type="html"><![CDATA[<h2 id="二分搜索（Binary-Search）"><a href="#二分搜索（Binary-Search）" class="headerlink" title="二分搜索（Binary Search）"></a>二分搜索（Binary Search）</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt; static Rank binSearch (T* s,T const &amp; e, Rank lo, Rank hi)&#123;    while( lo &lt; hi)&#123;&#x2F;&#x2F;不变性：A[0,lo) &lt;&#x3D; e &lt;&#x3D; A[ hi,n)        Rank mi &#x3D; (lo + hi) &gt;&gt; 1;&#x2F;&#x2F;以中点为轴点，经比较后确定深入        e &lt; S[mi] ? hi &#x3D; mi : lo &#x3D; mi + 1; &#x2F;&#x2F;[lo,mi) 或[mi,hi)    &#125; &#x2F;&#x2F;出口时，A[lo &#x3D; hi]为大于e的最小元素    return --lo;&#x2F;&#x2F;故lo - 1即不大于e的元素的最大秩&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记</title>
      <link href="2020/01/14/2020.8.15%20note/"/>
      <url>2020/01/14/2020.8.15%20note/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>对于同一个状态，宽度优先搜索只经过一次，因此复杂度为O(状态数*转移的方式)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int INF &#x3D; 100000000;typedef pair&lt;int, int&gt; P;&#x2F;&#x2F;输入char maze[MAX_n][MAX_n+1];int N, M;int sx, sy;int gx, gy;int d[MAXN][MAXN];int dx[4] &#x3D; &#123;1,0,-1,0&#125;, dy [4]&#x3D; &#123;0,1,0,-1&#125;;int bfs()&#123;    queue&lt;P&gt; que;    for(int i &#x3D; 0; i &lt; N; ++i)        for(int j &#x3D; 0; j &lt; M; ++j) d[i][j] &#x3D; INF;        &#x2F;&#x2F;将起点加入队列，并把这一地点的距离设置为0；    que.push(P(sx, sy));    d[sx][sy] &#x3D; 0;    while(que.size())&#123;        P p &#x3D; que.front(); que.pop();        if(p.first &#x3D;&#x3D; gx &amp;&amp; p.second &#x3D;&#x3D; gy) break;        &#x2F;&#x2F;四个方向的循环        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;            int nx &#x3D; p.first + dx[i], ny &#x3D; p. second + dy[i];            if(0 &lt;&#x3D; nx &amp;&amp; nx &lt; N &amp;&amp; 0 &lt;&#x3D; ny &amp;&amp; ny &lt;&#x3D; M &amp;&amp; maze[nx][ny] !&#x3D; &#39;#&#39; &amp;&amp; d[nx][ny] &#x3D;&#x3D; INF)&#123;                que.push(P(nx, ny));                d[nx][ny] &#x3D; d[p.first][p.second] + 1;]            &#125;        &#125;    &#125;    return d[gx][gy];&#125;void solve()&#123;    int res &#x3D; bfs();    printf(&quot;%d\n&quot;, res); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记</title>
      <link href="2020/01/14/2020.8.14%20note/"/>
      <url>2020/01/14/2020.8.14%20note/</url>
      
        <content type="html"><![CDATA[<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stack&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123;    stack&lt;int&gt; s;    s.push(1);    s.push(2);    s.push(3);    printf(&quot;%d\n&quot;, s.top());    s.pop();    printf(&quot;%d\n&quot;, s.top());    s.pop();    printf(&quot;%d\n&quot;, s.top());    s.pop();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123;    queue&lt;int&gt; que;    que.push(1);    que.push(2);    que.push(3);    printf(&quot;%d\n&quot;, que.front());    que.pop();    printf(&quot;%d\n&quot;, que.front());    que.pop();    printf(&quot;%d\n&quot;, que.front());    que.poo();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h1><p>简单来说就是一条路莽到底</p><p>部分和问题</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[MAX_n];int n, k;&#x2F;&#x2F; 已经从前i项得到了和sum， 然后对于i项之后的进行分支bool dfs(int i, int sum)&#123;    &#x2F;&#x2F;如果前i项都计算过了则返回sum是否与k相等    if(i &#x3D;&#x3D; n) return sum &#x3D;&#x3D; k;        &#x2F;&#x2F;不加上a[i]的情况    if(dfs(i + 1, sum)) return true;    &#x2F;&#x2F;加上a[i]的情况    if(dfs(i + 1, sum + a[i])) return true;    &#x2F;&#x2F;无论是否加上a[i]都不能凑成k就返回false    return false;&#125;void solve()&#123;    if(dfs(0,0)) printf(&quot;Yes\n&quot;);    else printf(&quot;No\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="2020/01/14/%E9%98%9F%E5%88%97/"/>
      <url>2020/01/14/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>实现一个队列，完成以下功能：</p><p>1.入列<br>2.出列<br>3.询问队列中位置Y是谁<br>一开始队列为空。队列中的位置从1开始（即队头位置为1）。</p><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>第一行一个整数n，表示操作个数。</p><p>接下来n行，每行第一个数字表示操作（见描述）：</p><p>若为数字1，则接下来有一串字符串X，表示将X加入队列。<br>若为数字2，表示出列（保证队列非空），并输出出列的这个人。<br>若为数字3，则接下来有一个整数Y，表示询问队列中位置Y是谁（保证位置Y合法），并输出名字。</p><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>将所有操作2和操作3输出，一行一个</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>11<br>1 a<br>1 b<br>1 c<br>3 1<br>3 2<br>3 3<br>2<br>1 d<br>3 1<br>3 2<br>3 3</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>a<br>b<br>c<br>a<br>b<br>c<br>d</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;string Queue[100000];int head,tail;void enqueue(string name) &#123;    Queue[tail++] &#x3D; name;&#125;string dequeue() &#123;    return Queue[head++];&#125;string query(int pos) &#123;    return Queue[head + pos - 1];&#125;int main() &#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    char name[20];    for (; n--; ) &#123;        int op;        scanf(&quot;%d&quot;, &amp;op);        if (op &#x3D;&#x3D; 1) &#123;            scanf(&quot;%s&quot;, name);            enqueue(name);        &#125; else if (op &#x3D;&#x3D; 2) &#123;            printf(&quot;%s\n&quot;, dequeue().c_str());        &#125; else &#123;            int pos;            scanf(&quot;%d&quot;, &amp;pos);            printf(&quot;%s\n&quot;, query(pos).c_str());        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基本数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高精度</title>
      <link href="2020/01/14/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>2020/01/14/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><p> 至此，就可以进行任意你想进行的运算了，首先我们来看看加法，其实上面的代码已经差不多写出来了。</p><p>高精度加法Code</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int a[6666],b[6666],c[6666];int lena,lenb,lenc;char s1[6666],s2[6666]; int main()&#123;    scanf(&quot;%s %s&quot;,s1+1,s2+1);    lena&#x3D;strlen(s1+1);    lenb&#x3D;strlen(s2+1);    for(int i&#x3D;1;i&lt;&#x3D;lena;i++) a[i]&#x3D;s1[lena-i+1]-&#39;0&#39;;    for(int i&#x3D;1;i&lt;&#x3D;lenb;i++) b[i]&#x3D;s2[lenb-i+1]-&#39;0&#39;;    lenc&#x3D;max(lena,lenb);    for(int i&#x3D;1;i&lt;&#x3D;lenc;i++)&#123;        c[i]&#x3D;c[i]+a[i]+b[i];        c[i+1]&#x3D;c[i]&#x2F;10;        c[i]&#x3D;c[i]%10;    &#125;    while(c[lenc+1]&gt;0) lenc++;    for(int i&#x3D;lenc;i&gt;0;i--) printf(&quot;%d&quot;,c[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><p>高精度减法Code</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int a[6666],b[6666],c[6666];int lena,lenb,lenc;char s1[6666],s2[6666]; int main()&#123;    scanf(&quot;%s %s&quot;,s1+1,s2+1);    lena&#x3D;strlen(s1+1);    lenb&#x3D;strlen(s2+1);    if(lenb&gt;lena||(lena&#x3D;&#x3D;lenb&amp;&amp;s2&gt;s1))&#123;&#x2F;&#x2F;如果第二个数比第一个数大，那么结果是负数    printf(&quot;-&quot;);    swap(s1,s2);&#x2F;&#x2F;swap是C++自带函数可以直接调用    swap(lena,lenb);&#x2F;&#x2F;别忘了交换长度    &#125;    for(int i&#x3D;1;i&lt;&#x3D;lena;i++) a[i]&#x3D;s1[lena-i+1]-&#39;0&#39;;    for(int i&#x3D;1;i&lt;&#x3D;lenb;i++) b[i]&#x3D;s2[lenb-i+1]-&#39;0&#39;;    lenc&#x3D;max(lena,lenb);    for(int i&#x3D;1;i&lt;&#x3D;lenc;i++)&#123;        c[i]&#x3D;c[i]+a[i]-b[i];        if(c[i]&lt;0) c[i]&#x3D;c[i]+10,c[i+1]&#x3D;-1;    &#125;    while(c[lenc]&#x3D;&#x3D;0&amp;&amp;lenc&gt;1) lenc--;    for(int i&#x3D;lenc;i&gt;0;i--) printf(&quot;%d&quot;,c[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><h3 id="高精度乘以单精度"><a href="#高精度乘以单精度" class="headerlink" title="高精度乘以单精度"></a>高精度乘以单精度</h3><p>高精度乘以单精度Code</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int a[6666],b;int lena;char s1[6666]; int main()&#123;    scanf(&quot;%s %d&quot;,s1+1,&amp;b);    lena&#x3D;strlen(s1+1);    for(int i&#x3D;1;i&lt;&#x3D;lena;i++) a[i]&#x3D;s1[lena-i+1]-&#39;0&#39;;    for(int i&#x3D;1;i&lt;&#x3D;lena;i++) a[i]*&#x3D;b;    for(int i&#x3D;1;i&lt;&#x3D;lena;i++)&#123;    a[i+1]+&#x3D;a[i]&#x2F;10;    a[i]%&#x3D;10;    &#125;    while(a[lena+1]&gt;0) lena++;    for(int i&#x3D;lena;i&gt;0;i--) printf(&quot;%d&quot;,a[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度乘以高精度"><a href="#高精度乘以高精度" class="headerlink" title="高精度乘以高精度"></a>高精度乘以高精度</h3><p>高精度乘以高精度Code</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int a[6666],b[6666],c[6666];int lena,lenb,lenc;char s1[6666],s2[6666]; int main()&#123;    scanf(&quot;%s %s&quot;,s1+1,s2+1);    lena&#x3D;strlen(s1+1);    lenb&#x3D;strlen(s2+1);    for(int i&#x3D;1;i&lt;&#x3D;lena;i++) a[i]&#x3D;s1[lena-i+1]-&#39;0&#39;;    for(int i&#x3D;1;i&lt;&#x3D;lenb;i++) b[i]&#x3D;s2[lenb-i+1]-&#39;0&#39;;    lenc&#x3D;lena+lenb-1;    for(int i&#x3D;1;i&lt;&#x3D;lena;i++)&#123;    for(int j&#x3D;1;j&lt;&#x3D;lenb;j++)&#123;    c[i+j-1]+&#x3D;a[i]*b[j];    c[i+j]+&#x3D;c[i+j-1]&#x2F;10;    c[i+j-1]%&#x3D;10;&#125;&#125;    while(c[lenc+1]&gt;0) lenc++;    for(int i&#x3D;lenc;i&gt;0;i--) printf(&quot;%d&quot;,c[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><h3 id="高精度除以单精度"><a href="#高精度除以单精度" class="headerlink" title="高精度除以单精度"></a>高精度除以单精度</h3><p>手动模拟一下，我们只要记录一个r，表示当前的余数，然后不断除就可以了。</p><p>高精度除以单精度Code</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int a[6666],b,r;int lena;char s1[6666]; int main()&#123;    scanf(&quot;%s %d&quot;,s1+1,&amp;b);    lena&#x3D;strlen(s1+1);    for(int i&#x3D;1;i&lt;&#x3D;lena;i++) a[i]&#x3D;s1[lena-i+1]-&#39;0&#39;;    for(int i&#x3D;lena;i&gt;0;i--)&#123;    r&#x3D;r*10+a[i];    a[i]&#x3D;r&#x2F;b;    r&#x3D;r%b;    &#125;    while(a[lena]&#x3D;&#x3D;0&amp;&amp;lena&gt;1) lena--;    for(int i&#x3D;lena;i&gt;0;i--) printf(&quot;%d&quot;,a[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度除以高精度"><a href="#高精度除以高精度" class="headerlink" title="高精度除以高精度"></a>高精度除以高精度</h3><p>我们知道除法是乘法的逆运算，那么我们为什么不可以看做是我们现在要求一个数乘以除数等于被除数呢？那么枚举肯定是不行的，这个时候我们就要用到二分啦（二分大发好啊~），没错高精度二分商，实际上就是一个高精度加法（mid=l+r），然后高精度除以单精度（mid/2），最后再高精度减法（r=mid-1）就可以实现二分了，我们二分出来的数直接高精度乘以高精度判断一下就可以了（代码中数组中的第0个位置表示此数的长度，瞬间暴露PC党……）。</p><p>高精度除以高精度Code</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int a[6666],b[6666],ans[6666],t[6666],l[6666],r[6666],mid[6666];char s1[6666],s2[6666]; int compare(int a[],int b[])&#123;    if(a[0]&gt;b[0]) return 0;    if(a[0]&lt;b[0]) return 1;    for(int i&#x3D;a[0];i&gt;0;i--)&#123;        if(a[i]&gt;b[i]) return 0;        if(a[i]&lt;b[i]) return 1;    &#125;    return 1;&#125; void add()&#123;    mid[0]&#x3D;max(l[0],r[0]);    for(int i&#x3D;1;i&lt;&#x3D;mid[0];i++) mid[i]&#x3D;l[i]+r[i];    while(mid[mid[0]+1]&gt;0) mid[0]++;    for(int i&#x3D;1;i&lt;&#x3D;mid[0];i++)&#123;        mid[i+1]+&#x3D;mid[i]&#x2F;10;        mid[i]%&#x3D;10;    &#125;    while(mid[mid[0]+1]&gt;0) mid[0]++;&#125; void times()&#123;    memset(t,0,sizeof(t));    t[0]&#x3D;b[0]+mid[0]-1;    for(int i&#x3D;1;i&lt;&#x3D;b[0];i++)&#123;        for(int j&#x3D;1;j&lt;&#x3D;mid[0];j++)&#123;            t[i+j-1]+&#x3D;b[i]*mid[j];            t[i+j]+&#x3D;t[i+j-1]&#x2F;10;            t[i+j-1]%&#x3D;10;        &#125;    &#125;    while(t[t[0]+1]&gt;0) t[0]++;&#125; void div()&#123;    int r&#x3D;0;    for(int i&#x3D;mid[0];i&gt;0;i--)&#123;        r&#x3D;r*10+mid[i];        mid[i]&#x3D;r&#x2F;2;        r%&#x3D;2;    &#125;    while(mid[mid[0]]&#x3D;&#x3D;0) mid[0]--;&#125; void left()&#123;    for(int i&#x3D;0;i&lt;&#x3D;mid[0];i++) l[i]&#x3D;ans[i]&#x3D;mid[i];    l[1]++;    for(int i&#x3D;1;i&lt;&#x3D;l[0];i++)&#123;        l[i+1]+&#x3D;l[i]&#x2F;10;        l[i]%&#x3D;10;    &#125;&#125; void right()&#123;    for(int i&#x3D;0;i&lt;&#x3D;mid[0];i++) r[i]&#x3D;mid[i];    r[1]--;    for(int i&#x3D;1;i&lt;&#x3D;r[0];i++)&#123;        if(r[i]&lt;0)&#123;            r[i+1]--;            r[i]+&#x3D;10;        &#125;    &#125;&#125; int main()&#123;    scanf(&quot;%s %s&quot;,s1+1,s2+1);    a[0]&#x3D;r[0]&#x3D;strlen(s1+1);    b[0]&#x3D;strlen(s2+1);    for(int i&#x3D;1;i&lt;&#x3D;a[0];i++) a[i]&#x3D;r[i]&#x3D;s1[a[0]-i+1]-&#39;0&#39;;    for(int i&#x3D;1;i&lt;&#x3D;b[0];i++) b[i]&#x3D;s2[b[0]-i+1]-&#39;0&#39;;    l[0]&#x3D;ans[0]&#x3D;1;    while(compare(l,r))&#123;        add();        div();        times();        if(compare(t,a)) left();        else right();    &#125;    for(int i&#x3D;ans[0];i&gt;0;i--) printf(&quot;%d&quot;,ans[i]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高精度开平方"><a href="#高精度开平方" class="headerlink" title="高精度开平方"></a>高精度开平方</h2><p>没错，还是二分。二分答案。利用高精度加法和高精度除以单精度可以实现二分的效果，然后直接高精度乘法乘起来再高精度比较一下大小，再用高精度减法移动一下l和r就可以了。其实这也算是高精度比较综合的做法了。码量虽然惊人，但其实高精度除以高精度改一改就好了</p><p>高精度开平方Code</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int a[6666],b[6666],ans[6666],t[6666],l[6666],r[6666],mid[6666];char s1[6666],s2[6666]; int compare(int a[],int b[])&#123;    if(a[0]&gt;b[0]) return 0;    if(a[0]&lt;b[0]) return 1;    for(int i&#x3D;a[0];i&gt;0;i--)&#123;        if(a[i]&gt;b[i]) return 0;        if(a[i]&lt;b[i]) return 1;    &#125;    return 1;&#125; void add()&#123;    mid[0]&#x3D;max(l[0],r[0]);    for(int i&#x3D;1;i&lt;&#x3D;mid[0];i++) mid[i]&#x3D;l[i]+r[i];    while(mid[mid[0]+1]&gt;0) mid[0]++;    for(int i&#x3D;1;i&lt;&#x3D;mid[0];i++)&#123;        mid[i+1]+&#x3D;mid[i]&#x2F;10;        mid[i]%&#x3D;10;    &#125;    while(mid[mid[0]+1]&gt;0) mid[0]++;&#125; void times()&#123;    memset(t,0,sizeof(t));    t[0]&#x3D;mid[0]+mid[0]-1;    for(int i&#x3D;1;i&lt;&#x3D;mid[0];i++)&#123;        for(int j&#x3D;1;j&lt;&#x3D;mid[0];j++)&#123;            t[i+j-1]+&#x3D;mid[i]*mid[j];            t[i+j]+&#x3D;t[i+j-1]&#x2F;10;            t[i+j-1]%&#x3D;10;        &#125;    &#125;    while(t[t[0]+1]&gt;0) t[0]++;&#125; void div()&#123;    int r&#x3D;0;    for(int i&#x3D;mid[0];i&gt;0;i--)&#123;        r&#x3D;r*10+mid[i];        mid[i]&#x3D;r&#x2F;2;        r%&#x3D;2;    &#125;    while(mid[mid[0]]&#x3D;&#x3D;0) mid[0]--;&#125; void left()&#123;    for(int i&#x3D;0;i&lt;&#x3D;mid[0];i++) l[i]&#x3D;ans[i]&#x3D;mid[i];    l[1]++;    for(int i&#x3D;1;i&lt;&#x3D;l[0];i++)&#123;        l[i+1]+&#x3D;l[i]&#x2F;10;        l[i]%&#x3D;10;    &#125;&#125; void right()&#123;    for(int i&#x3D;0;i&lt;&#x3D;mid[0];i++) r[i]&#x3D;mid[i];    r[1]--;    for(int i&#x3D;1;i&lt;&#x3D;r[0];i++)&#123;        if(r[i]&lt;0)&#123;            r[i+1]--;            r[i]+&#x3D;10;        &#125;    &#125;&#125; int main()&#123;    scanf(&quot;%s&quot;,s1+1);    a[0]&#x3D;r[0]&#x3D;strlen(s1+1);    for(int i&#x3D;1;i&lt;&#x3D;a[0];i++) a[i]&#x3D;r[i]&#x3D;s1[a[0]-i+1]-&#39;0&#39;;    l[0]&#x3D;ans[0]&#x3D;1;    while(compare(l,r))&#123;        add();        div();        times();        if(compare(t,a)) left();        else right();    &#125;    for(int i&#x3D;ans[0];i&gt;0;i--) printf(&quot;%d&quot;,ans[i]);    return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序 Sorting</title>
      <link href="2020/01/10/%E6%8E%92%E5%BA%8F%20Sorting/"/>
      <url>2020/01/10/%E6%8E%92%E5%BA%8F%20Sorting/</url>
      
        <content type="html"><![CDATA[<h2 id="Gnomesort-Naive-Improved"><a href="#Gnomesort-Naive-Improved" class="headerlink" title="Gnomesort: Naive + Improved"></a>Gnomesort: Naive + Improved</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">naiveGnomesort(s[], n) &#x2F;&#x2F;single loop but O(n^2)  for(int i &#x3D; 1; i &lt; n; )&#123;      if(i &lt; 1 || s[i-1] &lt;&#x3D; s[i]) &#x2F;&#x2F;GREEDY      i++;&#x2F;&#x2F;inefficient backtracking      else         &#123;              swap ( s[ i-1], s[i]);            i--;        &#125;  &#125;improveGnomesort(s[], n)&#x2F;&#x2F;nested loops and still o(n^2) &#123;for(int k &#x3D; 1; k &lt; n ; k++) &#x2F;&#x2F;Since s[0,k) is always sorted, we can  for(int i &#x3D; k; 0 &lt; i &amp;&amp; s[i-1] &gt; s[i]; i-- ) &#x2F;&#x2F;backtrack to k and rescan    swap( s[i-1], s[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Bubblesort-Basic"><a href="#Bubblesort-Basic" class="headerlink" title="Bubblesort: Basic"></a>Bubblesort: Basic</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt; void Vector&lt;T&gt;:: bubbleSort ( Rank lo, Rank hi)&#123;  while( lo &lt; hi)  bubble( lo, hi--);&#x2F;&#x2F;逐趟做扫描交换&#125;template &lt;typename T&gt; void Vector&lt;T&gt;:: bubble( Rank lo, Rank hi)&#123;  while(++lo &lt; hi)&#123;&#x2F;&#x2F;从左向右，逐一检查各对相邻元素    if( _elem[lo-1] &gt; _elem[lo] )&#x2F;&#x2F;若逆序      swap( _elem[lo-1], _elem[lo]);&#x2F;&#x2F;交换  &#125;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Bubblesort-提前终止"><a href="#Bubblesort-提前终止" class="headerlink" title="Bubblesort: 提前终止"></a>Bubblesort: 提前终止</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt; void Vector&lt;T&gt;:: bubbleSort ( Rank lo, Rank hi)&#123;  while( ! bubble( lo, hi--))&#x2F;&#x2F;逐趟做扫描交换&#125;template &lt;typename T&gt; bool Vector&lt;T&gt;:: bubble( Rank lo, Rank hi)&#123;  bool sorted &#x3D; true;  while(++lo &lt; hi)&#123;&#x2F;&#x2F;从左向右，逐一检查各对相邻元素    if( _elem[lo-1] &gt; _elem[lo] )&#123;&#x2F;&#x2F;若逆序      sorted &#x3D; false;      swap( _elem[lo-1], _elem[lo]);&#x2F;&#x2F;交换  &#125;  return sorted;&#x2F;&#x2F;整体有序&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Bubblesort-跳过无效起泡"><a href="#Bubblesort-跳过无效起泡" class="headerlink" title="Bubblesort: 跳过无效起泡"></a>Bubblesort: 跳过无效起泡</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt; void Vector&lt;T&gt;:: bubbleSort ( Rank lo, Rank hi)&#123;  while( lo &lt; ( hin &#x3D; bubble( lo, hi)))&#x2F;&#x2F;逐趟做扫描交换,直至全序&#125;template &lt;typename T&gt; bool Vector&lt;T&gt;:: bubble( Rank lo, Rank hi)&#123;  Rank last &#x3D; lo;  while(++lo &lt; hi)&#123;&#x2F;&#x2F;从左向右，逐一检查各对相邻元素    if( _elem[lo-1] &gt; _elem[lo] )&#123;&#x2F;&#x2F;若逆序      last &#x3D; lo;&#x2F;&#x2F;更新最右侧逆序对位置记录，并      swap( _elem[lo-1], _elem[lo]);&#x2F;&#x2F;交换  &#125;  return last;&#x2F;&#x2F;逆序对均在last以左<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T,int size&gt;void sort(T(&amp;array)[size])&#x2F;&#x2F;数组排序模版&#123;    for(int i&#x3D;0;i&lt;size;i++)&#x2F;&#x2F;从第一个开始遍历数组size次，默认将第一个视为最小元素；    &#123;        T min&#x3D;array[i];&#x2F;&#x2F;暂时将当前元素当作最小值        int k&#x3D;i;&#x2F;&#x2F;记录当前地址        for(int j&#x3D;i+1;j&lt;size;j++)&#x2F;&#x2F;遍历未排序元素        &#123;            if(array[j]&lt;min)&#x2F;&#x2F;如果未排序元素中有比当前值还小的            &#123;                min&#x3D;array[j];&#x2F;&#x2F;更新最小值                k&#x3D;j;&#x2F;&#x2F;更新最小值地址            &#125;        &#125;        if(k!&#x3D;i)&#x2F;&#x2F;当一遍循环结束后如果最小元素不是当前值，将最小元素与当前值进行交换        &#123;            array[k]&#x3D;array[i];            array[i]&#x3D;min;        &#125;    &#125;&#125;————————————————版权声明：本文为CSDN博主「liqiluan」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_39352109&#x2F;article&#x2F;details&#x2F;88378108<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="QuickSelect"><a href="#QuickSelect" class="headerlink" title="QuickSelect"></a>QuickSelect</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt; void quickSelect( Vector&lt;T&gt; &amp; A, Rank k)&#123;  for(Rank lo &#x3D; 0, hi &#x3D; A.size() -  1; lo &lt; hi; )&#123;    Rank i &#x3D; lo, j &#x3D; hi; T pivot &#x3D; A[lo];    while(i &lt; j)&#123;      while( pivot &lt;&#x3D; A[j] )&#123; j--; A[i] &#x3D; A[j];&#125;      while( A[i] &lt;&#x3D; pivot ) &#123; i++; A[j] &#x3D; A[i];&#125;    &#125;    A[i] &#x3D; pivot;    if( k &lt;&#x3D; i ) hi &#x3D; i - 1;    if( i &lt;&#x3D; k ) lo &#x3D; i + 1;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;stdio.h&gt;using namespace std;int a[100001],temp[100001];void bin(int l,int r)&#123;    if(l&#x3D;&#x3D;r) return ;    int mid&#x3D;(l+r)&gt;&gt;1;    bin(l,mid);    bin(mid+1,r);    int i&#x3D;l,j&#x3D;mid+1,k&#x3D;l;    while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;r)     &#123;        if(a[i]&lt;&#x3D;a[j]) &#123;            temp[k]&#x3D;a[i];            k++,i++;        &#125;        else         &#123;            temp[k]&#x3D;a[j];            k++,j++;        &#125;    &#125;        while(i&lt;&#x3D;mid)    &#123;        temp[k]&#x3D;a[i];        k++,i++;    &#125;    while(j&lt;&#x3D;r)    &#123;        temp[k]&#x3D;a[j];        k++,j++;    &#125;    for(int i&#x3D;l;i&lt;&#x3D;r;++i)&#123;        a[i]&#x3D;temp[i];    &#125;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;        scanf(&quot;%d&quot;,&amp;a[i]);    &#125;    bin(1,n);    for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;        printf(&quot;%d &quot;,a[i]);    &#125;    return 0;&#125;&#x2F;&#x2F;原文地址：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;qseer&#x2F;p&#x2F;9419949.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;using namespace std;#define range 10000void CountingSort(int a[],int b[],int len)&#123;int cnt&#x3D;0;for(int i&#x3D;0;i&lt;len;i++)&#123;b[a[i]]++;&#125;for(int i&#x3D;0;i&lt;len;i++)while(b[i]!&#x3D;0)&#123;a[cnt++]&#x3D;i;b[i]--;&#125;&#125; int main()&#123;clock_t start,end;start&#x3D;clock();freopen(&quot;out_arr.txt&quot;,&quot;r&quot;,stdin);freopen(&quot;out_计数排序.txt&quot;,&quot;w&quot;,stdout);int a[range],b[range]&#x3D;&#123;0&#125;;for(int i&#x3D;0;i&lt;range;i++)&#123;scanf(&quot;%d&quot;,&amp;a[i]);&#125;CountingSort(a,b,range);for(int i&#x3D;0;i&lt;range;i++)&#123;printf(&quot;%5d &quot;,a[i]);if((i+1)%50&#x3D;&#x3D;0)printf(&quot;\n&quot;);&#125;end&#x3D;clock();printf(&quot;计数排序耗时：%dms\n&quot;,(float)(end-start)*1000.0&#x2F;CLOCKS_PER_SEC);return 0;————————————————版权声明：本文为CSDN博主「生于忧患，死于安乐2017」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41325698&#x2F;article&#x2F;details&#x2F;88095563<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>木块问题</title>
      <link href="2020/01/09/%E6%9C%A8%E5%9D%97%E9%97%AE%E9%A2%98/"/>
      <url>2020/01/09/%E6%9C%A8%E5%9D%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>输入n，得到编号为0 —- n-1的木块，分别摆放在顺序排列编号为0 – n-1的位置。现对这些木块进行操作，操作分为四种。</p><p>1、move a onto b：把木块a、b上方的木块放回各自的原位，再把a放到b上；</p><p>2、move a over b：把a上方的木块放回各自的原位，再把a放到b所在的木块的堆的上面；</p><p>3、pile a onto b：把b上方的木块放回各自的原位，再把a连同a上的木块整体移到b上；</p><p>4、pile a over b：把a连同a上方木块移到b所在的木块的堆的上面。</p><p>当输入quit时，结束操作并输出0~n-1的位置上的木块情况</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>10<br>move 9 onto 1<br>move 8 over 1<br>move 7 over 1<br>move 6 over 1<br>pile 8 over 6<br>pile 8 over 5<br>move 2 over 1<br>move 4 over 9<br>quit</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>0: 0<br>1: 1 9 2 4<br>2:<br>3: 3<br>4:<br>5: 5 8 7 6<br>6:<br>7:<br>8:<br>9:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;const int maxn &#x3D; 30;int n;vector&lt;int&gt; pile[maxn];&#x2F;&#x2F;找木块a所在的pile和height， 以引用的形式返回调用者void find_block(int a, int&amp; p, int&amp; h) &#123;for ( p &#x3D; 0; p &lt; n; p++)for ( h &#x3D; 0; h &lt; pile[p].size(); h++)if (pile[p][h] &#x3D;&#x3D; a) return;&#125;&#x2F;&#x2F;把第p堆高度为h的木块上方的所有木块移回原位置void clear_above(int p, int h) &#123;for (int i &#x3D; h + 1; i &lt; pile[p].size(); i++) &#123;int b &#x3D; pile[p][i];pile[b].push_back(b);&#125;pile[p].resize(h + 1); &#x2F;&#x2F;只保留下标0~h的元素  .resize()改变大小&#125;&#x2F;&#x2F;把第p堆高度为h及其上方的木块整体移动到p2堆的顶部void pile_onto(int p, int h, int p2) &#123;for (int i &#x3D; h; i &lt; pile[p].size(); i++)pile[p2].push_back(pile[p][i]);pile[p].resize(h);&#125;void print() &#123;for (int i &#x3D; 0; i &lt; n; i++) &#123;printf(&quot;%d:&quot;, i);for (int j &#x3D; 0; j &lt; pile[i].size(); j++) printf(&quot; %d&quot;, pile[i][j]);printf(&quot;\n&quot;);&#125;&#125;int main() &#123;int a, b;cin &gt;&gt; n;string s1, s2;for (int i &#x3D; 0; i &lt; n; i++) pile[i].push_back(i);while (cin &gt;&gt; s1 &gt;&gt; a &gt;&gt; s2 &gt;&gt; b) &#123;int pa, pb, ha, hb;find_block(a, pa, ha);find_block(b, pb, hb);if (pa &#x3D;&#x3D; pb) continue;if (s2 &#x3D;&#x3D; &quot;onto&quot;) clear_above(pb, hb);if (s1 &#x3D;&#x3D; &quot;move&quot;) clear_above(pa, ha);pile_onto(pa, ha, pb);&#125;print();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
